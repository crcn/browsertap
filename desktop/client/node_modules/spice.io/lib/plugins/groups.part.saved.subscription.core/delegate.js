var cashew = require('cashew'), 
vine = require('vine'), 
cron = require('cron2'),
logger = require('winston').loggers.get('groups.gart.saved.subscription.core'),
sprintf = require('sprintf').sprintf;

var Delegate = module.exports = function(router, db, manager)
{
	
	//subscribes to a particular group. Twitter, Facebook accounts. Emails, etc.
	var c_subscribers = db.collection('group.subscribers'),
	
	//information regarding the group, such as the frequency of which the newsletter is sent
	c_info = db.collection('group.subscription.info'),
	
	//generates an ID for the given subscriber
	idGen = cashew.register('group.subscribers'),
	
	//times when a newsletter is sent off
	c_history = db.collection('group.subscription.sent.history'),
	
	self = this;


	function startSlave()
	{
		router.on({

			/**
			 */

			'push thyme/ready': function()
			{
				//timed based on the interval set for the group
				this.from.push('thyme/worker', { queue: process.env.SLAVE_APP_NAME, path: 'send/subscription/by/group', max: 3, timeout: 20000, lockTTL: 20000, tries: 3 });

				//time based on the individual recipient
				this.from.push('thyme/worker', { queue: process.env.SLAVE_APP_NAME, path: 'send/subscription/by/recipient', max: 30, timeout: 20000, lockTTL: 20000, tries: -1 });
			},

			/**
			 */

			'pull -hook send/subscription/by/group': function(req, res)
			{
				logger.verbose('sending subscription by group');

				var data = this.data();
				
				c_subscribers.find({ group: data._id }, function(err, cursor)
				{
					cursor.each(function(err, item)
					{
						if(!item) return;

						data.recipient = item;

						logger.verbose(sprintf('adding recipient "%s" to thyme in %d ms', item.value, cron.timeout(item.cron)));

						router.push('thyme/job', { queue: process.env.SLAVE_APP_NAME, 
							_id: item._id, 
							path: 'send/subscription/by/recipient', 
							data: data,
							sendAt: cron.sendAt(item.cron) });
					})
				});	
				

				res.end();
				
				
				
				//insert the history so we can provide nice clean line breaks - notifying *what* items were sent at *what* time
				c_history.insert({ group: data._id, sentAt: Date.now() });
			},

			/**
			 */

			'pull -hook send/subscription/by/recipient': function(req, res)
			{
				console.log('sending subscription by recipient');

				var subscriber = req.query.recipient,
				groupId = subscriber.group

				//meh for now >.>
				subscriber.group = req.query;
				subscriber.group._id = groupId;
				// subscriber.unsubscribeUrl = 'groups/:group/subscribers/:subscriberId/remove';

				
				subscriber.loadNewsletterArticles = function(ops, callback)
				{
					router.request('groups/' + subscriber.group._id + '/articles', { afterDate: ops.afterDate, count: ops.count }).tag('method','GET').success(callback).pull();
					//to-do....
				}

				manager.notify(subscriber, function()
				{
					console.log('Sent subscription');
					
					c_subscribers.update({ _id: subscriber._id }, { $set: { lastSentAt: new Date() }}, function(){});
					res.end();
				});

			}

		});
	}


	router.on({

		/**
		 */
		
		'push -pull init/slave': function()
		{
			startSlave();
		},

		/** 
		 * pushed from groups.part.saved.core
		 */

		'push notify/subscribers': function(item)
		{        
			console.log('Notify subscribers');       
			
			//increment an update
			c_info.update({ group: item.group.toString() }, { $inc: { updates: 1 }}, function(){ });
			
			//after the group has been updated, try sending the newsletter
			trySending(item.group.toString());
		}
	});


	function trySending(group, now)
	{
		console.log("Try sending group");

		function onGroup(group, subscriptionInfo)
		{             
			console.log('adding thyme job to send subscription');

				
			router.request('profile/internal', { _id: group.profile }).success(function(response) 
			{
				var profile = response.result;

				delete profile.password;

				//option of course to ignore the cron, and send the newsletter immediately
				var sendAt = now != undefined ? Date.now() : cron.sendAt(subscriptionInfo.cron) ;


				                
				                
				// console.log('sending thyme job now'); 
				
				if(now) {
					logger.verbose('sending subscription now');
				} else {
					logger.verbose(sprintf('sending subscription in %s ms', cron.timeout(subscriptionInfo.cron)));
				}
				                                                 
				router.push('thyme/job', { queue: process.env.SLAVE_APP_NAME, 
					_id: subscriptionInfo.group, 
					path: 'send/subscription/by/group', 
					data: { 
						name: group.name,
						description: group.description,
						_id: subscriptionInfo.group,
						profile: profile
					}, 
					sendAt: sendAt 
				});	

			}).pull();
			
			
		}
		
		function onSubscriptionInfo(subscriptionInfo)
		{   
			console.log("Group %s has %d updates", subscriptionInfo.group, subscriptionInfo.updates || 0);                         
			
			if(subscriptionInfo.updates)
			{
				if(typeof group == 'string')
				{
					router.request('groups/' + subscriptionInfo.group).tag('method','GET').success(function(response)
					{
						onGroup(response.result, subscriptionInfo);
					}).pull();
				}
				else
				{
					onGroup(group, subscriptionInfo);
				}
				
				
			}
		}
		
		self.getSubscriptionInfo(group, onSubscriptionInfo);
	}
	
	this.notifySubscribers = trySending;


	this.getSubscriptionInfo = function(groupOrGroupId, callback)
	{
		console.log('Get subscription info');

		var groupId = groupOrGroupId._id || groupOrGroupId;
		
		
		c_info.findOne({ group: groupId }, function(err, item)
		{
			
			//once a day
			if(!item) return self.updateSubscriptionInfo(groupId, { cron: '00 00 23 * * 6', skipSend: true }, callback);

			callback(item);
		})
	}

	this.updateSubscriptionInfo = function(groupId, data, callback)
	{
		console.log('Update subscriber info');

		var toUpdate = {};

		if(data.cron) 
		{
			toUpdate.cron = data.cron;
			// toUpdate.sendAt = cron.sendAt(data.cron);
		}


		c_info.update({ group: groupId }, { $set: toUpdate }, { upsert: true }, function(err, item)
		{
			self.getSubscriptionInfo( groupId, function(item)
			{
				callback(item);

				if(!data.skipSend) trySending(groupId, callback);
			});
		})
	}

	this.getSubscribers = function(groupId, page, limit, callback)
	{
		if(!page) page = 0;
		if(!limit) limit =  30;

		c_subscribers.find({ group: groupId.toString() }, { limit: limit, skip: limit * page }, function(err, cursor)
		{
			cursor.toArray(function(err, items)
			{
				callback(items);
			})
		})
	}

	this.getSubscriber = function(groupId, subscriberId, callback)
	{
		c_subscribers.findOne({ group: groupId.toString(), _id: subscriberId }, function(err, subscriber)
		{
			callback(subscriber);
		})
	}

	this.removeSubscriber = function(subscriberId, subscriberKey, callback)
	{
		c_subscribers.remove({ _id: subscriberId/*, key: subscriberKey*/ }, function(err, result)
		{
			callback();
		})
	}

	this.updateSubscriber = function(info, callback)
	{

		manager.validate(info, function(api)
		{
			if(api.errors) return callback(api);

			var subscriber = api.result, search;

			// subscriber.sendAt = cron.sendAt(subscriber.cron);



			function fetchSubscriber(id)
			{
				c_subscribers.findOne({ _id: id }, function(err, item)
				{
					callback(vine.result(item).end());
				});
			}

			if(info.subscriberId)
			{
				c_subscribers.update({ _id: info.subscriberId }, { $set: subscriber }, function()
				{
					fetchSubscriber(info.subscriberId);
				});	
			}
			else
			{
				search = { group: info.groupId, value: subscriber.value };
				
				subscriber.group = info.groupId;

				c_subscribers.findOne(search, function(err, item)
				{
					if(!item)
					{
						subscriber.createdAt = new Date();
						subscriber._id = idGen.uid();
						subscriber.key = idGen.random();

						c_subscribers.insert(subscriber, function(err, item)
						{
							callback(vine.result(item).end());
						});
					}
					else
					{
						c_subscribers.update({ _id: item._id }, { $set: subscriber }, function()
						{
							fetchSubscriber(item._id);
						});
					}
				});
			}


			
		});
	}
}