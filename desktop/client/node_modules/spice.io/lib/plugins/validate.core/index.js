var vine = require('vine'),
beanpoll = require('beanpoll'),
_ = require('underscore'),
logger = require('winston').loggers.get('validate.core');


exports.plugin = function(router) {
	

	router.use(require('./validator'));


	//setup really basic validators
	// var validatorKeys = {}; //id:key combined



	var validateRouter = beanpoll.router();


	function getValidator(key, validator) {
		
		if(validator instanceof RegExp) {

			return function(req) {
				
				if(!validator.test(req.value)) throw new Error(key + ' is invalid.');

				req.next();
			}

		} else {
			
			return validator;

		}

	}


	router.on({

		/**
		 */

		'validate email': /.+/,


		/**
		 * incase something does not exist - it'll be caught by not existing
		 */

		'validate :item': function(value, next) {
			next();
		},


		/**
		 */


		'pull validate OR validate/:paths': function(req, res, mw) {
					
			if(!mw.sanitized) req.sanitized = mw.sanitized = {};

			var toValidate = req.params.paths ? req.params.paths.split('+') : Object.keys(req.query),
			numRunning = toValidate.length + 1,
			allData = mw.flattenData(),
			errors = [];

			allData.__sanitized = req.sanitized;


			logger.verbose('validating ' + toValidate.join(', '));

			var onValidated = function() {
				
				if(--numRunning) return;

				if(errors.length) return vine.error(errors).end(res);

				if(!mw.next()) {
					
					vine.result(mw.sanitized).end(res);

				}
			}

			toValidate.forEach(function(key) {


				router.
				request(key).
				query(allData).
				headers(_.extend(mw.last.tags)).
				error(function(err) {
					errors.push(err);
					onValidated();
				}).
				success(function(sanitized) {
					
					_.extend(mw.sanitized, sanitized);

					onValidated();
				}).
				validate();

			});


			onValidated();
		}

	});
}