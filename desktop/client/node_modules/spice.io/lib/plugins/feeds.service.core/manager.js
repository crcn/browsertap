var Structr = require('structr'),
vine = require('vine'),
logger  = require('winston').loggers.get('feed.service.core'),
sprintf = require('sprintf').sprintf,
outcome = require("outcome");


var IdentityTester = Structr({
	
	/**
	 */


	'__construct': function(test, handler)
	{
		//object vs regexp?
		if(test.value)
		{
			//match = should match
			this._match = test.value;

			//not = should NOT match
			this._not = test.not;
		}
		else
		{
			this._match = test;
		}

		this.default = handler.default;
		this.isPrivate = handler.service.isPrivate;


		var source = this.source = { match: this._getRegexpInfo(this._match) };

		if(this.not) source.not = this._getRegexpInfo(this._not);
		if(this.default) source.default = true;
	},

	/**
	 */

	'match': function(value)
	{

		var match = value.match(this._match);

		//if there's a match, and there's NOT a match for the "not" regexp, then return it
		return match && !(this._not || !value.match(this._not)) ? match : null;
	},


	/**
	 */


	'_getRegexpInfo': function(regexp)
	{
		return { source: regexp.source, flags: regexp.toString().match(/\/(\w*)$/)[1] };
	},


	/**
	 */


	'toJSON': function()
	{
		return this.source;
	}
})




var IdentifyManager = Structr({
	
	/**
	 */


	'__construct': function(test, handler)
	{
		//object vs regexp?
		if(test.value)
		{
			//match = should match
			this._match = test.value;

			//not = should NOT match
			this._not = test.not;
		}
		else
		{
			this._match = test;
		}

		this.default = handler.default;
		this.isPrivate = handler.service.isPrivate;


		var source = this.source = { match: this._getRegexpInfo(this._match) };

		if(this.not) source.not = this._getRegexpInfo(this._not);
		if(this.default) source.default = true;
	},

	/**
	 */

	'match': function(value)
	{

		var match = value.match(this._match);

		//if there's a match, and there's NOT a match for the "not" regexp, then return it
		return match && !(this._not || !value.match(this._not)) ? match : null;
	},


	/**
	 */


	'_getRegexpInfo': function(regexp)
	{
		return { source: regexp.source, flags: regexp.toString().match(/\/(\w*)$/)[1] };
	},


	/**
	 */


	'toJSON': function()
	{
		return this.source;
	}
})


var Identifier = Structr({
	
	/**
	 */

	'__construct': function(target, service)
	{
		//default tester? this is used against all feeds if any fail (secondary)
		this.default = target.default;

		//the target quick input tester obj
		this.target  = target;

		//the target service loader
		this.service  = service;

		var testers = this.testers = [], self = this;

		//tests = regexp
		(target.test instanceof Array ? target.test : [target.test]).forEach(function(tester)
		{
			testers.push(new IdentityTester(tester, self));
		});
	},

	/**
	 * trys to handle the value given
	 */

	'tryHandling': function(data, callback)
	{

		//Note: we need to pass the data because it could contain other important
		//information such as the user account used.
		var testers = this.testers, match,
		feeds = [],
		self = this;



		for(var i = testers.length; i--;)
		{
			if(match = testers[i].match(data))
			{
				return this._feed(match, function(err, dataCollection)
				{
					if(err) return vine.error(err);

					if(!(dataCollection instanceof Array)) dataCollection = [dataCollection];

					for(var i = dataCollection.length; i--;)
					{

						var feed = self.service.validate({ data: dataCollection[i] });


						if(!feed) continue;

						feeds.push(feed);
					}

					callback(vine.result(feeds));
				});
			}
		}

		return false;
	},


	/**
	 */

	'_feed': function(data, callback)
	{
		this.target.feed(data, callback);

		return true;
	}

});


var IdentityManager = Structr({
	
	/**
	 */

	'__construct': function()
	{
		this._primaryIdentifiers = [];
		this._secondaryIdentifiers = [];
	},

	/**
	 */

	'addService': function(service)
	{
		var target = service.target;

		//quick input regexp?
		if(target.identify)
		{
			var self = this;

			(target.identify instanceof Array ? target.identify : [target.identify]).forEach(function(tester)
			{
				var identifier = new Identifier(tester, service);


				(identifier.default ? self._secondaryIdentifiers : self._primaryIdentifiers).push(identifier);
			});
		}
	},

	/**
	 */
	
	'identify': function(feeds, callback)
	{
		if(!(feeds instanceof Array)) feeds = [feeds];

		var nLeft = feeds.length,
		result = vine.api(),
		self = this;



		feeds.forEach(function(feed)
		{
			function onLoader(api)
			{
				result = result.combine(api);

				if(!(--nLeft)) callback(result);
			}

			var success = self._tryHandling(self._primaryIdentifiers, feed, onLoader) || self._tryHandling(self._secondaryIdentifiers, feed, onLoader);

			if(!success)
			{
				return onLoader(vine.error('Cannot add feed "%s" because it\'s currently not supported, but it will be.', feed));
			}
		})

		
	},

	/**
	 */

	'_tryHandling': function(identifiers, feed, callback)
	{
		for(var i = identifiers.length; i--;)
		{
			var ident = identifiers[i];

			if(ident.tryHandling(feed, callback)) return true;
		}

		return false;
	}

})


var Service = Structr({
	
	/**
	 */


	'__construct': function(target, parser, feed)
	{

		this.parser = parser;

		this._feed = feed;


		//the target object
		this.target = target;

		//name of the service
		this.name = target.name;

		//required params
		this.params = target.params || {};

		//requires an account to use
		this.isPrivate = !!this.params.account;
	},

	/**
	 */

	'getData': function(data)
	{
		if(!data) data = {};
		var newData = {};

		for(var prop in this.params)
		{
			if(!data[prop]) return null;

			newData[prop] = data[prop];
		}

		return newData;
	},

	/**
	 */


	'load': function(data, callback)
	{
		this.target.load(data, callback);
	},

	/**
	 */

	'render': function(data)
	{
		return this.target.renderData(data);
	},

	/**
	 */

	'validate': function(feed)
	{
		var d = this.getData(feed.data);


		if(!d) return null;

		feed.target = this;
		feed.data = d;

		if(!feed.action) feed.action = this._feed.action;
		if(!feed.service) feed.service = this._feed.service;
		if(!feed.category) feed.category = this._feed.category;

		feed.toJSON = function()
		{
			return { service: feed.service, 
				category: feed.category, 
				action: feed.action, 
				data: feed.data, 
				feedId: feed.feedId };
		}


		//unique ID of the feed with the given data
		feed.feedId = this.parser.toQs(feed);

		return feed;
	}
});




var FeedParser = Structr({

	/**
	 */

	'__construct': function(table)
	{
		this.table = table;
	},
	
	/**
	 * parses string to a handleable object. e.g:
	 * search:twitter+facebook:users:q=test:v=anothervalue
	 */

	'parseQs': function(feedString)
	{
		var feedParts = feedString.split(':'),
		actions        = feedParts.shift().split('+'), //search, get, update
		services       = this._service(feedParts.shift()).split('+'), //twitter, facebook, facebook+youtube
		categories     = feedParts.shift().split('+'),//users, friends+wall, status
		data = {};


		feedParts.forEach(function(v)
		{
			var vParts = v.split('=');
			
			//the value MUST be escaped. what if it's a url?
			data[vParts[0]] = unescape(vParts[1]);	
		});	

		//now we can start building our feed
		var batch = [];

		actions.forEach(function(action)
		{
			services.forEach(function(service)
			{
				categories.forEach(function(category)
				{
					var feed = {
						action: action.toLowerCase(),
						service: service.toLowerCase(),
						category: (category || 'default').toLowerCase(),
						data: Structr.copy(data)
					};

					batch.push(feed);
				});
			});	
		});
		
		return batch;
	},

	/**
	 */

	'ids': function(batch)
	{
		if(!(batch instanceof Array)) batch = [batch];
		
		var ids = new Array(batch.length);
		
		for(var i = batch.length; i--;)
		{
			ids[i] = this.toQs(batch[i]);
		}	

		return ids;
	},

	/**
	 */

	'_service': function(serv)
	{
		return serv == '*' || serv == 'all' ? this.table.services.join('+') : serv;
	},


	/**
	 * puts data back to a feed s
	 */

	 'toQs': function(batch)
	 {
	 	if(!(batch instanceof Array)) batch = [batch];

	 	var params = {
	 		action :[],
	 		service :[],
	 		category :[]
		};

		var data = {}, self = this;

	 	batch.forEach(function(feed)
	 	{
	 		if(!feed) return;

	 		feed.service = self._service(feed.service);

	 		for(var param in params)
	 		{
	 			if(params[param].indexOf(feed[param]) == -1)
	 			{
		 			params[param].push(feed[param]);
		 		}
	 		}

	 		for(var param in feed.data)
	 		{
	 			data[param] = feed.data[param];
	 		}
	 	});


	 	var feedString = params.action.join('+') + ':' + params.service.join('+') + ':' + params.category;


	 	for(var param in data)
	 	{
	 		feedString += ':' + param + '=' + escape(data[param]);	
	 	}

	 	return feedString;
	 }
});


var TransformerCollection = Structr({
	
	/**
	 */

	'__construct': function(table)
	{
		this._transformers = [];

		this.table = table;
	},

	/**
	 */

	'add': function(feeder)
	{
		this._transformers.push(feeder);

		this._transformers.sort(function(a, b)
		{
			return a.priority > b.priority;
		})
	}
});


/**
 * splits apart data. This comes after a loader has required a particular parameter, and it exists, *and* needs to be fetched such as accounts
 */




var FeedTransformer = TransformerCollection.extend({
	
	'transform': function(feeds, req, callback)
	{
		logger.verbose(sprintf('trying to transform feeds: %s', feeds));

		var toTransform = [],
		transformed = [],
		target = { feeds: feeds, req: req };


		for(var i = this._transformers.length; i--;)
		{
			if(this._transformers[i].test(target)) toTransform.push({ transformer: this._transformers[i], target: target }); 
		}

		var numTransforming = toTransform.length;

		if(!numTransforming) return callback(feeds instanceof Array ? feeds : [feeds]);


		toTransform.forEach(function(info)
		{
			info.transformer.feeds( info.target, function(feeds)
			{
				if(!(feeds instanceof Array)) feeds = [feeds];

				transformed = transformed.concat(feeds);

				if(!(--numTransforming)) callback(transformed);
			});
		});
		
	}
});


var Feeder = TransformerCollection.extend({
	
	/**
	 */

	'override __construct': function(table)
	{
		this._super(table);

		this.table = table;

		this.add({
			priority: 999,
			test: function(ops)
			{
				return ops.service && ops.action;
			},
			feeds: function(ops, callback)
			{
				callback(null, [{ service: ops.service, category: ops.category, action: ops.action, data: ops.data }]);
			}
		});


		this.add({
			priority: 0,
			test: function(ops)
			{
				return !!ops.feed;
			},
			feeds: function(ops, callback)
			{
				table.identifier.identify(ops.feed, function(vine)
				{
					callback(null, vine.result() || []);
				})
			}
		});


		this.add({
			priority: 1,
			test: function(ops)
			{
				return ops.feed ? ops.feed.match(/(\w+|\*):(\w+|\*):(\w+|\*)/) : false;
			},
			feeds: function(ops, callback)
			{                                  
				var feeds = table.parser.parseQs(ops.feed);     
				                       

				for(var i = feeds.length; i--;)
				{
					Structr.copy(ops.data, feeds[i].data, true);
				}                

				callback(null, feeds);
			}
		});
	},


	/**
	 */

	'feeds': function(ops, data, callback)
	{
		if(!callback)
		{
			callback = data;
			data = {};
		}

		var self = this;

		for(var i = this._transformers.length; i--;)
		{
			var transformer = this._transformers[i];

			if(transformer.test(ops))
			{
				console.log(ops);

				return transformer.feeds(ops, function(err, feeds)
				{        
					console.log(feeds) 
					self.table.feeds(feeds, data, callback);
				});
			}
		}

		return callback();
	}
});


var ServiceTable = Structr({
	
	/**
	 */

	'__construct': function()
	{
		this._loaders = { };
		this.services = [];

		//used for removing
		this._loadersByCategory = {};


		//identifies a feed 
		this.identifier = new IdentityManager();

		//parses the feed query string
		this.parser = new FeedParser(this);

		//interprets "feed". Could be group, a url, etc.
		this.feeder = new Feeder(this);

		//transforms data, and adds feeds based on what's there. E.g: "accounts" would add accounts to the feed
		this.transformer = new FeedTransformer(this);
	},
	

	/**
	 */

	'add': function(service)
	{
		var loaders = service.loaders,
			name = service.name;

		if(!name) return console.warn('Unable to add service because name doesn\'t exist');
		

		logger.verbose(sprintf('adding service: %s', name));

		//need to make the service a littler more friendly. to lower case
		//and NO funky characters
		this._loaders[name = name.toLowerCase().replace(/[^\w]/g,'')] = {};
		//loaders are categorized by category, and action. Category being
		//something like: books, videos, me, profile, friend. Action being something like:
		//search, update, home, etc.

		if(this.services.indexOf(name) == -1) this.services.push(name);

		for(var cat in loaders)
		{
			this._loaders[name][cat] = {};

			for(var act in loaders[cat])
			{
				this.identifier.addService(this._loaders[name][cat][act] = new Service(loaders[cat][act], this.parser, { service: name, category: cat, action: act }));
			}
		}
	},

	/**
	 */

	'feeds': function(feed, data, callback)
	{
		
		var feeds = this._feeds(feed), self = this;


		this.transformer.transform(feeds, data, function(feeds)
		{

			for(var i = feeds.length; i--;)
			{
				var feed = feeds[i],
				service = self.service(feed);

				if(service) feed = service.validate(feed);   
				                            

				if(!feed || !service)
				{
					feeds.splice(i, 1);
					continue;
				}

				feeds[i] = feed;
			}


			callback(feeds);	
		});
	},

	/**
	 */


	'_feeds': function(feed, callback)
	{
		if(typeof feed == 'string')
		{
			return this.parser.parseQs(feed);
		}
		else

		//array? it's processed most likely
		if(feed instanceof Array)
		{
			return feed;
		}

		//could be from URI ~ service: twitter+facebook, category: videos+photos, etc.
		else
		{
			var data = feed.data,
			feed = {
				service: feed.service,
				category: feed.category,
				action: feed.action
			};

			var feeds = this.parser.parseQs(this.parser.toQs(feed));

			for(var i = feeds.length; i--;)
			{
				var feed = feeds[i];
				feed.data = data;
			}

			return feeds;
		}

		return [];
	},

	/**
	 */

	'service': function(feed)
	{
		try
		{                        
			return this._loaders[feed.service][feed.category][feed.action];
		}catch(e)
		{
			return null;
		}
	}
});



module.exports = ServiceTable;
