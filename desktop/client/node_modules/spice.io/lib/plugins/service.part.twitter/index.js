var Twitter    = require('./twitter').Twitter,    
request = require('request'),
TwitterAuthHandler = require('./auth').TwitterAuthHandler,
Queue = require('sk/core/queue').Queue,
smart = require('sk/core/smart').smart,
Url = require('url'),
logger = require('winston').loggers.get('search.part.twitter'),
sprintf = require('sprintf').sprintf;

exports.plugin = function(router, params)
{           

	var auth = new TwitterAuthHandler(params);
	
	var service = new (function ()
	{				
		this.auth = auth;
		var t = new Twitter(this.auth);     
                             
		this.follow = t.followUser;      
		this.unfollow = t.unfollowUser;
		this.following = t.followingUser;
		this.loadData = function (data, method, callback)
		{
			t[method](data, function (response)
			{                                      
				callback(!response || response.error, response ? response.results || (response instanceof Array ? response : []) : null); 
			});
		}

		this.updateStatus = function (data, callback)
		{
			t.updateStatus(data, callback);
		}


		this.userLookup = function(account, userIds, callbacks)
		{
			var max = 100,
			n = Math.ceil(userIds.length / max),
			q = new Queue();

			for(var i = n; i--;)
			{
				q.add(function()
				{
					var start = (i++) * max;

					var lookup = userIds.slice(start, start + max);

					t.userLookup(account, lookup.join(','), function(users)
					{
						callbacks.add(users);


						q.next();
					});
				});
			}	

			q.add(function()
			{
				callbacks.finish();
			});

			i++;

			q.next();


			// t.userLookup(search, callback);
		}

		this.unfollow = function(account, screenName, callback)
		{
			t.unfollow(account, screenName, callback);
		}

		this.follow = function(account, screenName, callback)
		{
			t.follow(account, screenName, callback);
		}

		this.getFollowing = function(account, callback)
		{
			t.getFollowing(account, callback);
		}

		//loads the account feeds associated with wha
		this.getAccountFeeds = function (account, callback)
		{
			var groups = [];

			t.getAccountLists(account, function (data)
			{  
				var q = new Queue(true);

				for(var i = data.lists.length; i--;)
				{

					q.add(function ()
					{
						var list = data.lists[i];
						var group = {name: list.slug, feeds: []};
						t.getPrivateListMembers (list, account, function (users)
						{
							for(var j = users.length; j--;)
							{
								var user = users[j];
								group.feeds.push('http://twitter.com/' + user.screen_name);
							} 

							q.next();
						})	 

						groups.push(group);
					})
				}

				q.add(function ()
				{
					callback(groups);
					q.next();
				})
			})
		}
	});
	      
	function getSocialService(req, res)
	{
		function renderSearchData(rawData)
		{   
			
			//DO NOT add _id because doing so will make a unique tweet which cannot be re-displayed in another search                       
			return {type: 'post',
					label: rawData.from_user, 
					createdAt: new Date(rawData.created_at),
					icon: rawData.profile_image_url, 
					text: rawData.text};
		}

		function renderUserStreamData(rawData)
		{                          
			return {type: 'post',
					label: rawData.user.screen_name, 
					createdAt: new Date(rawData.created_at), 
					icon: rawData.user.profile_image_url,
					text: rawData.text};
		}

		var searchTwitter = 
		{
			name: 'Keyword Search',
			label:'Keyword Search: %q',
			params: {q:1},
			renderData: renderSearchData,

			//users can add feeds with 
			identify: 
			[{ 
				test: [/twitter\.com\/.*?search\?q\=([^&]+)/,
				/twitter\.com\/.*?search\/([^?\/]+)/,     
				/^#(\w+)$/],
				feed: function (result, callback)
				{
					callback(false, {q:unescape(result[1])});
				}
			}],
			load: function (data, callback)
			{    
				logger.verbose(sprintf('searching for "%s" on twitter', data.q))

				//data.count
				var pageSize = Math.min(data.maxFeedRecords, 100);
				
				var nPages = (data.isNew ? Math.ceil(data.maxFeedRecords / pageSize) : 1) + 1;
				
				// console.log(data.isNew);
				// console.log(Math.ceil(data.maxFeedRecords / pageSize));
				// console.log('loading '+nPages+' twitter pages');
				
				for(var i = 1; i < nPages; i++)
				{ 
					service.loadData({ q: data.q, rpp: pageSize, page: i }, 'search', callback);
				}
			}
		}

		var info = 
		{
			type: 'graph',
			name: 'Twitter',
			service: service,
			loaders:
			{
				default:
				{
					search: searchTwitter
				},    
				buzz:
				{
					search: searchTwitter
				}/*,
				feeds:
				{
					pull: 
					{
						name: "Sync Twitter Lists",
						params: { account: 1 },
						load: function(ops, callback)
						{
							service.getAccountFeeds(ops.account, function(accounts)
							{
								console.log(accounts);
							})
						}
					}
				}*/,
				wall:
				{
					post: 
					{
						name: 'Update',
						auth: 'twitter',
						params: {status: 'input' },
						load:function (data, callback)
						{                   
							service.updateStatus(data, callback)
						}
					},
				},
				posts:
				{
					search: searchTwitter,
					user:
					{
						name: 'User', 
						params: {q:1},
						renderData: renderUserStreamData,
						identify:
						{
							test: [/twitter\.com\/\#\!\/(\w+)$/,
							/twitter\.com\/(\w+)$/,  
							/wefollow.com\/(\w+)$/,
							/^\@(\w+)$/],
							feed: function (result, callback)
							{
								callback(false, {q:result[1]});
							}
						},
						load:function (data, callback)
						{
							service.loadData({screen_name: data.q}, 'getUserTimeline', callback);
						}   
					}
					,home:
					{
						name: 'Home',
						auth: 'twitter',
						renderData: renderUserStreamData,
						load:function ()
						{
						}
					}
				}
			}
		}

		info.loaders.default = info.loaders.posts;
		res.end(info);


		//TODO: put this in a different file, sheeesh
		//start the trending
		function loadTrending()
		{
			var t = new Twitter();
			t.loadDailyTrending(function(trending)
			{
				for(var i in trending.trends)
				{
					var date = trending.trends[i];

					for(var j = date.length; j--;)
					{
						var trend = date[j].query;
						p.mediator.pull('loadNew','default/twitter/search', { q: trend }, { wait: false }, function(){});
					}
					break;
				}
			});
		}

		//not yet...
		if(false && process.env.SLAVE)
		{
			//let's load the twitter trends every day. This will pop up in the top under /hot/all
			smart.interval(loadTrending,1000*60*60*12,true);
		}
	}
	
	
	function getContentStandardizer(req, res)
	{         
		
		var std = function(item)
		{                     
			var text     = item.text,
				media = item.media;

		   	var hashtags = text.match(/#\w+/g),
				users    = text.match(/@\w+/g),
				used     = {};

			if(hashtags)
			{                         
				hashtags.forEach(function (hash)
				{
					if(used[hash]) return;

					used[hash] = 1;
					media.push({data: hash, type: 'hashtag', match: hash, link: 'http://twitter.com/search/' + hash});
				})
			}                       


			if(users)
			{   
				users.forEach(function(user)
				{   
					if(used[user]) return;
					used[user] = 1;
					media.push({data: user, type: 'mention', match: user, link: 'http://twitter.com/' + user.replace('@','')});
				})
			}             
		}
		
		//augments links
		res.end({ standardize: std, service: 'twitter' });
	}
	
	function getPromotionFinder(req, res)
	{
		res.end({
			service: 'twitter', 
			// interval: 50,
			test: function ()
			{
				return true;
			},
			find: function (item, callback)
			{

				var urlParts = Url.parse(item.link);


				//twitter can't handle hashes
				if(urlParts.hash) return callback(0);

				request.get({
					url: 'http://urls.api.twitter.com/1/urls/count.json',
					form: { url: item.link },
					json: true
				}, function(err, response, body) {
					callback(body ? body.count : null);
				});
			}
		})
	}
	
	function getSuggestionHandler(req, res)
	{
		//tbd... this requires authentication >.>
	}                             
	
	function getSubscribables(req, res)
	{
		var subscribable = {  
			type: 'twitter',
		    auth: 'twitter',      
			name: 'Twitter',
			subscribe: function(data, callback)
			{                                      
				service.follow(data.account, data.to, callback)
			},
			unsubscribe: function(data, callback)
			{
				service.unfollow(data.account, data.to, callback);
			},
			subscribed :function(data, callback)
			{
			   service.following(data.account, data.to, callback); 
			}
		}     
		
		res.end(subscribable);
	} 

	function getAuthHandler(req, res)
	{
		res.end(auth);
	}

	function getFeedPuller(req, res)
	{
		res.end({
			type: 'twitter',
			service:'twitter',
			load: function(account, delegate)
			{
				var q = new Queue(true);

				function lookup(group, userids)
				{
					service.userLookup(account, userids, {
						add: function(users)
						{
							var feeds = [];

							for(var i = users.length; i--;)
							{
								feeds.push({ group: group, feed: '@' + users[i].screen_name, details: users[i] });
							}

							delegate.add(feeds);
						},
						finish: function()
						{
							q.next();
						}
					});
				}

				q.add(function()
				{
					service.getFollowing(account, function(following)
					{
						lookup('following', following);
					});
				});

				q.add(function()
				{
					delegate.finish();
				})
			},
			unsubscribe: function(account, user, callback)
			{
				service.unfollow(account, user.feed.substr(1), callback);
			},
			subscribe: function(account, user, callback)
			{
				service.follow(account, user.feed.substr(1), callback);
			}
		});
	}
	
	
	router.on({   

		//pulls feeds for the given account
		'collect feed/puller': getFeedPuller,

		'collect connect/auth': getAuthHandler,
		                               
		//returns the items which are subscribable (following a user)
		'collect subscribable': getSubscribables,
		
		//handles twitter requests via social.core
		'collect social/service': getSocialService,
		
		//standardizes twitter posts 
		'collect content/standardizer': getContentStandardizer,
		
		//find promoted content based on N likes
		'collect promotion/finder': getPromotionFinder,
		
		//recommends people to follow based on keywords
		'collect suggestion/handler': getSuggestionHandler
	});
}
