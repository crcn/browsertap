
var Structr = require('structr'),
	smart = require('sk/core/smart'),
	SmartCacher  = smart.Cacher,
	Queue = require('sk/core/queue').Queue,
	lazy = require('sk/core/lazy').lazy,
logger = require('winston').loggers.get('feeds.stream.core'),
sprintf = require('sprintf').sprintf;


var SiteImageCacher = Structr({

	/**
	 */
	 	
	'__construct': function(site, dumpFrequency, cacher) {

		this._cacher  = cacher;
		this._collection = cacher._collection;
		this._dumpFeq = dumpFrequency; 
		this._site = site;

		this._save = {};

		var interval = setInterval(this.getMethod('_saveImages'), 1000 * 60);
		

		//dispose the cacher after N seconds since it's not being used
		this._dispose = lazy.callback(function() {

			// console.log('disposing site image cacher for %s', site);

			delete cacher._loaded[site];

			clearInterval(interval);
		}, 1000 * 60 * 5);


		//start the countdown to dispose
		this._dispose();
	},

	/**
	 */

	'tryUsing': function(image, callback) {


		//reset the countdown
		this._dispose();


		if(this._usedImages) {

			var numUses = this._usedImages[image] = (this._usedImages[image] || 0) + 1;

			this._save[image] = numUses;


			return callback(numUses <= 1);
		}

		var used = this._usedImages = {},
		self = this;


		this._collection.find({ site: this._site }, function(err, cursor) {

			if(err) {

				logger.error(err, { stack: err.stack });
				return callback(false);
			}


			cursor.each(function(err, item) {

				//done
				if(!item) return self.tryUsing(image, callback);

				used[item.image] = item.uses;
			});
		});
	},


	/**
	 */

	'_saveImages': function() {

		// console.log('saving used images for %s', this._site);

		var checkAt = new Date(new Date().getTime() + this._dumpFeq);


		for(var image in this._save) {

			var uses = this._save[image];

			this._collection.update({ site: this._site, image: image }, {$set: { uses: uses, checkAt: checkAt }}, { upsert: true }, function() {

				
			});
		}
	}


})


var OverUsedImageCacher = Structr({
	
	/**
	 * Constructor.
	 */

	 '__construct': function(manager) {

	 	this._db = manager.db;

	 	this._collection = this._db.collection('overusedImages');

	 	//the sites which are currently loaded into memory
	 	this._loaded = {};

	 	setInterval(this.getMethod('_dumpUnique'), 1000 * 60 * 24);
	 	this._dumpUnique(); //on bootup
	 },


	 'tryUsing': function(site, image, frequency, callback) {

	 	if(!callback) {

	 		callback = frequency;
	 		frequency = 1000 * 60 * 3;// 3 hours
	 	}



	 	return (this._loaded[site] ? this._loaded[site] : (this._loaded[site] = new SiteImageCacher(site, frequency, this))).tryUsing(image, callback)
	 },

	 '_dumpUnique': function() {

	 	logger.verbose('Dumping unique images');
	 	this._collection.remove({ uses: 1, checkAt: { $lt: new Date() }}, function(){});

	 	//remove 2 weeks old
	 	this._collection.remove({ checkAt: { $lt: new Date(Date.now() - 1000 * 60 * 60 * 24 * 14) }}, function(){});
	 }
}) 


exports.OverUsedImageCacher = OverUsedImageCacher;