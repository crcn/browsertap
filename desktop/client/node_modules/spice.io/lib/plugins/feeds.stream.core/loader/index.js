var Structr = require('structr'),
vine = require('vine'),
Standardizer = require('./standardizer'),
_ = require('underscore'),
logger = require('winston').loggers.get('feeds.stream.core'),
sprintf = require('sprintf').sprintf;



var TrendsLoader = Structr({
	
	/**
	 */

	'__construct': function(delegate, ops) {

		this.delegate = delegate;
		this.streamLoader = ops.streamLoader;
	},

	/**
	 */

	'trending': function(method, ops, callback) {

		this.streamLoader.load({ feeds: ops.feeds });

		var feedIds = _.pluck(ops.feeds, 'feedId');
		
		this.delegate[method](feedIds, ops, function(err, promos) {

			if(err) return callback(err, vine.error('Unable to fetch promotions'));

			callback(false, vine.list(promos));
		})
	},

	/**
	 */

	'new': function(ops, callback) {

		this.trending('new', ops, callback);
	},

	/**
	 */
	
	'top': function(ops, callback) {

		this.trending('top', ops, callback);
	},

	/**
	 */

	'hot': function(ops, callback) {

		this.trending('hot', ops, callback);
	}
	
})


var StreamLoader = Structr({
	
	/**
	 */

	'__construct': function(delegate, ops) {

		this.delegate 		 = delegate;
		this.plugin 		 = delegate.plugin;
		this._maxFeedRecords = this.plugin.appParams.maxStreamFeedRecords || 30;
		this.standardizer    = ops.standardizer;
	},

	/**
	 */

	'load': function(ops, callback) {

                                                                                                                           
		
		if(!ops) ops = {};

		//async? respond immediately
		var wait = ops.wait != undefined,

		feeds = ops.feeds || [];                                                       

		//when stuff is happening behind the scehes
		var skipFetch = ops.skipFetch,

		//the feed ids we're about to load
		feedIds = _.pluck(feeds, 'feedId'),

		//number of feeds left before all are done loading
		feedsLeft = feedIds.length,   
		                              
		//called by the queue
		ignoreWatch = ops.ignoreWatch,

		//already called back?
		responded = false,

		self = this,

		api = vine.api();     
		                   


		function tryFinish() {


			if(responded) return;


			logger.verbose('stream finished');

			if(!wait || !(--feedsLeft)) {

				responded = true;

				var search = { feedId: {
				 $in: feedIds }};

				if(callback)
				if(skipFetch) {

					callback(api.result());
				}
				else {

					self.delegate.getFeedData(search, { page: ops.page || 0, count: ops.count || 30 }, function(err, result) {

						callback(err, api.result(result));
					});	
				}

				
			}
		}

		if(!wait || !feeds.length) tryFinish();   
		                             

		feeds.forEach(function(feed) {

			logger.verbose(sprintf('loading feed: %s', feed.feedId));

			var target = feed.target,
			data = feed.data,
			id = feed.feedId;


			if(!target) {

				logger.verbose('no target, trying to finish');
				return tryFinish();
			}


			 
			self.delegate.walkThroughStream(id, {

				
				/**
				 */

				fail: function() {

					logger.verbose(feed.feedId + ' failed');

					tryFinish();
				},

				/**
				 */

				load: function(isNew, callback) {


					logger.verbose(sprintf("load new data for %s", feed.feedId));

					data.isNew = isNew;
					data.maxFeedRecords = self._maxFeedRecords;


					target.load(data, function(err, items) {


						if(err || !items) return callback(false);

						var processed = [];

						try {
        
							//rebuild the stack so it's consistend
							for(var i = items.length; i--;) {

								var item = items[i];  

								//let's convert the data over to something we can use eh? If the returned is false, then 
								//there's probably something wrong with the data, or we SHOUDN'T add it.
								if(item = target.render(item)) processed.push(item);  
							}  
						}
						catch(e) {

							logger.error(e, { stack: e.stack });
						}


						callback(processed);
					});
				},

				/**
				 */

				processUseableFeedItems: function(useable) {

					//standardizes the way text, and media are for the particular item
					var service = feed.service;    


				 	//once we've found the useable data, go through and 
			    	//standardize the data once more - removing HTML, adding media, etc. This is the 
					//heavier stuff. whereas renderData is a bit lighter
					if(!target.ignoreStandardization)
					for(var i = useable.length; i--;) {
     
						var item = useable[i]; 

						//set the additional stuff
						item.service = service;

						//if auth is present then the item is private   
						// if(loader.auth) item.private = true;

						self.standardizer.standardizeFeedItem(item);
					} 
				},

				/**
				 */

				finish: function(useable) {

					for(var i = useable.length; i--;) {

						var item = useable[i];

						if(item.link) self.plugin.router.push('promote', item);
					}

					tryFinish();

					if(!ignoreWatch) self.delegate.watchFeed(id);
				}
			})
		});


	}
})

var Loader = Structr({

	/**
	 */

	'__construct': function(dbm) {

		var standardizer = this.standardizer = new Standardizer(),
		sl = this.streamLoader = new StreamLoader(dbm.feeds, this).wrap(),
		tl = this.trendLoader = new TrendsLoader(dbm.promotions, this).wrap();

		this['stream'] = sl['load'];
		this['new']    = tl['new'];
		this['hot']    = tl['hot'];
		this['top']    = tl['top'];
	}
})


var LoadManager = Structr({


	/**
	 */

	'__construct': function(dbManager) {

		this._loader = new Loader(dbManager).wrap();
		this.standardizer = this._loader.standardizer;
	},

	/**
	 */

	'addContentStandardizer': function(standardizer) {

		this.standardizer.addContentStandardizer(standardizer);
	},

	/**
	 */

	'load': function(type, ops, callback) {

		this._loader[type](ops, callback);
	}
});


module.exports = LoadManager;
