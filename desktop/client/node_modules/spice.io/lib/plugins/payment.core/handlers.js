var Structr = require('structr'),
	Queue = require('sk/core/queue').Queue,
	delegate = require('./delegates'),
	PaymentDelegate = delegate.PaymentDelegate;



var PayableItemsHandler = Structr({
	'__construct': function(mediator)
	{
		this._payableItems = {};
		this._prices = {};
		
		mediator.on('push -pull payableItem', this.getMethod('addPayableItem'));
	},
	'addPayableItem': function(item)
	{
		for(var category in item)
		{
			this._setBasePrices(category, this._payableItems[category] = item[category]);
		}
	},
	'_setBasePrices': function(cat, payable)
	{
		var self = this;
		payable({amount:1}, function(data)
		{
			self._prices[cat] = data;
		});
	},
	'getPrices': function(callback)
	{
		callback(this._prices);
	},
	'pay': function(orderInfo, callback)
	{
		var orderInfoIsString = typeof orderInfo == 'string';
		
		
		//string? it's a single item we're paying for...
		var category = orderInfoIsString ? orderInfo : orderInfo.type;
		
		var payableItem = this._payableItems[category];
		
		if(!payableItem) return callback('payable item does not exist');
		
		payableItem(orderInfoIsString ? {amount:1} : orderInfo, function(item)
		{
			callback(false, item)
		});
	}
})


var PaymentHandlers = Structr({
	'__construct': function(mediator)
	{
		this._paymentHandlers = {};
		this._payableHandler = new PayableItemsHandler(mediator);
		this._mediator = mediator;
		
		var self = this;
		
		function onMongoDb(mongoose)
		{
			self._dg = new PaymentDelegate(mediator, mongoose);
		}
		mediator.on({
			'push -pull mongodb': onMongoDb,
			'paymentHandler': this.getMethod('addPaymentHandler'),
			'pull substractBalance': this.getMethod('subtractBalance')
		});
	},
	'addPaymentHandler' : function(handler)
	{
		this._paymentHandlers[handler.service] = handler;
		
		handler.init(this._payableHandler);
	},
	'getPaymentDialogUrl': function(service, data)
	{
		var handler = this._paymentHandlers[service];
		return handler ? handler.getPaymentDialogUrl(data) : null;
	},
	'getPaymentBalance': function(secret, callback)
	{
		this._dg.getPaymentBalance(secret, function(err, amount)
		{
			callback(amount);
		})
	},
	'subtractBalance': function(req, res)
	{
		var data = pull.data,
			callback = res.end;
		
		var q = new Queue(),
			self = this,
			totalSubtractions = 0;
		
		function addItem(category, amount)
		{
			q.add(function()
			{
				self._payableHandler.pay({type:category,amount:amount}, function(err, item)
				{
					if(!err) totalSubtractions += item.priceAfterFree == undefined ? item.price : item.priceAfterFree;
					
					q.next();
				});
			})
		}
		
		for(var i = data.paid.length; i--;)
		{
			var item = data.paid[i];
			
			for(var cat in item)
			{
				addItem(cat, item[cat]);
			}
		}
		
		q.add(function()
		{
			if(totalSubtractions) self._dg.subtractBalance(data.profile, totalSubtractions);
		})
		
		q.start();
		
	},
	'getPrices': function(callback)
	{
		this._payableHandler.getPrices(callback);
	},
	'handlePayment': function(data, callback)
	{
		var handler = this._paymentHandlers[data.service],
			self = this;
			
		if(!handler) return callback('handler does not exist');
		
		handler.handlePayment(data, {
			handshake: callback,
			settled: function(data)
			{
				
				self._mediator.pull('accounts',  data.user, function(users)
				{
					if(!users.length) return callback('user does not exist');
					
					var user = users[0];
					
					var data2 = {
						profile: user.profile,
						items: data.items
					}
					
					self._dg.addPayment(data2, callback);
				});
				
			}
		})
	}
});



exports.PaymentHandlers = PaymentHandlers;