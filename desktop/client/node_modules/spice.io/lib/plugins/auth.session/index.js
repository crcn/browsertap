var models = require('./model'),
vine = require('vine'),
cashew = require('cashew'),
_ = require('underscore'),
logger = require('winston').loggers.get('auth.profile'),
outcome = require('outcome'),
sprintf = require('sprintf').sprintf;

exports.plugin = function(router) {                          
	

	//the token model
	var Token, tokens = {}, idGen = cashew.register('tokens'), ObjectId 
	

	//generates a token key which is used to access private data
	function generateKey() {
		return idGen.uid() + '|' + idGen.random().substr(8); //remove first 8 characters (identifier)     
	}     
	      
	
	router.on({

		/**
		 */

		'validate -passive -key=token|accessToken -assign=token token': function(req, next) {

			var search = {};


			if(req.sanitized.tokenGranter) {

				//both granter & grantee are important so we get the granters *own* token
				search.granter =  search.grantee = req.sanitized.tokenGranter;
			} else {
				search.key = req.value;
			}


			Token.findOne(search, outcome.error(next).success(function(token) {
				
				if(!token) return next(new Error('token does not exist'));

				logger.verbose(sprintf('token %s was found', token.key));

				next(null, token);
			}));

		},
		
		/**
		 */
		
		'push \
		mongodb': function(db) {  
		       
			Token = models(db).Token; 
			ObjectId = db.base.Types.ObjectId;

		},
		
		/**
		 * Returns a new token to access private apis 
		 * @optional secret the secret to store in the token     
		 * @optional ttl time in seconds to keep the token alive for    
		 * @collection profile             
		 */
		
		'pull \
		token OR \
		token/create': function(req, res) {  
		                                                            
			var d = req.query,
			ttl = d.ttl ? Number(d.ttl) * 1000 : -1,
			grantee = d.grantee;

			if(!grantee) return vine.error('grantee is not present').end(res);

			function onToken(token) {

				_.extend(token, {    

					//time to keep the token alive for
					ttl: ttl,

					//used for the db
					expireAt: ttl > -1 ? new Date(Date.now() + ttl) : null,

					//if setting to self, scope must be all
					scope: String(grantee) == String(d.granter) ? ['*'] : (d.scope || token._doc.scope)
				});

				console.log(token._doc)


				token.save(function(err) {

					if(err) return vine.error('Unable to fetch token').end(res);

					vine.result(token).end(res);

				}); 
			}


			//don't create a new token if one already exists
			Token.findOne({ granter: d.granter, grantee: grantee }, function(err, token) {

				if(token) {

					onToken(token);

				} else {

					onToken(new Token({ granter: d.granter, grantee: grantee, key: generateKey(), scope: d.scope || [ '*' ] }));
				}

			});                               
		},  
		
		/**
		 * validates whether a token exists
		 */
		
	   	'pull \
	   	token/:key OR \
	   	token/validate': function(req, res, mw) { 

	   		logger.verbose('fetching token from DB')
	   	    
			var d = mw.data();



			Token.findOne({ key: d.token || d.key }, res.success(function(token) {

				if(!token) {

					return vine.error('token does not exist').end(res); 

				}

				//check for expiration
				if(token.expiresAt && token.expiresAt.getTime() > Date.now()) {

					token.remove();
					
					return vine.error('token has expired').end(res);   

				}

				req.token = token;
				
				if(!mw.next()) return vine.result(token).end(res);

			}));  
		},
		
		/**
		 * pulls the token by secret
		 */                         
		
		'pull \
		token/by/granter': function(req, res) {

			Token.findOne({ granter: req.query.granter }, res.success(function(token) {          
			                                                       
				if(!token) return vine.error('token does not exist').end(res);
				
				vine.result(token).end(res);

			}));
		},
		
		/**!
		 * Refresh a given token
		 * @param token the token to refresh
		 * @optional ttl the time in seconds to refresh the token     
		 * @collection profile    
		 * @displayName renewAccessToken
		 */
		
		'pull \
		-method=GET \
		token/:token -> \
			token/renew OR \
			token/:token/renew': function(req, res) {      
		          
			var d = req.query;
			
			if(!d.token) return vine.error("token param is not present").end(es);  
			             
			req.token.key = generateKey();  
			req.token.save();         
			vine.result(req.token).end(res);

		},

		/**
		 * fetches all tokens granted to given token
		 */

		'pull -method=GET validate/token -> tokens': function(req, res, mw) {

			
			/*

			Definition:

			1. GRANTER is the physical owner of the token granted access GRANTEE
			2. GRANTEE is the person granted access to the token
			3. SCOPES are the items the GRANTEE has access to with given token


			Notes:

			1. There is only ONE grantee associated with a granter. Less stuff in the db. Easier to manage.

			Scope Parts:

			ACTION:COLLECTION:ITEM

			Explained:

			1. ACTION is the action a GRANTEE has over the following scopes - SET, UPDATE, DELETE, etc.
			2. CATEGORY is the group the GRANTEE has access over. Examples might be sending emails, modifying groups, etc.
			3. ITEM is the very specific item a GRANTEE has access over. For instance, I might only want to share friends to a particular digest, or project for collab

			Example:

			GET:group:[id] - get a specific group item
			DELETE:group   - delete any group
			*:group        - any action on any group
			*              - any action on any group
			GET            - get any group 




			*/

			//the CURRENT permissions
			var permLevel, 

			//levels split from permLevel
			permLevels,

			//the ITEM grouping
			permItem,
			
			//the specific ID derrived from permItem
			permId, 

			cur = mw.current, 

			//permissions required by THIS route
			requiredPermissions = { '*': 1 },

			//flatten ALL data so we can get the permId
			data = mw.flattenData(),

			//used incase there isn't a token match. item access is used to query against collections
			collections = {};


			//need to start off by gathering ALL the permissions for the given
			//route since we're going through middleware. The tokens route should 
			//only be accessed ONCE because of this.
			while(cur) {

				//perm example: USER|GROUP|GET_GROUP
				permLevel = cur.tags.perm;


				//perm level is just boolean? Borrow it from method, which is an action
				//AGAINST an item
				if(typeof permLevel == 'object' || typeof permLevel == 'boolean') {
					permLevel = cur.tags.method;
				} else {
					permLevel = 'user';
				}


				//perm can *also* be boolean, just -perm. This is reserved
				//for greedy middleware
				if(typeof permLevel == 'string') {

					permLevels = permLevel.split('|').concat('*');
					permItem   = cur.tags.item; //item is generic because it's reusable 
					permValue  = data[permItem];

					if(permItem && !collections[permItem]) {
						collections[permItem] = [];

						//help the routes out a bit by building the mongodb query
						var query = collections[permItem].query = { $in: collections[permItem] };
					}


					for(var i = permLevels.length; i--;) {

						permLevel = permLevels[i];

						//super action check: GET, DELETE, PUT, SEND, etc ~ custom stuff if you want

						//by action
						var options = [[permLevel]];

						//by specific category
						if(permItem)  options.push([permLevel, permItem]);

						//by specific value
						if(permValue) options.push([permLevel, permItem, permValue]);

						//setup the permissions HASH lookup table
						for(var j = options.length; j--;) {

							requiredPermissions[ options[j].join(':').toLowerCase() ] = 1;

						}
							
					}
				}

				cur = cur.getNextSibling();
			}


			Token.find( { grantee: req.sanitized.token.grantee }, res.success(function(tokens) {

				//the granters giving access to THIS route
				var granters = [],

				//the items we have access to in THIS route
				items = {},

				grantedTokens = [];

				for(var i = tokens.length; i--;) {
					
					var token = tokens[i],

					//check if the scope is part of the required permissions
					scope = token.scope,

					//first we need to check if we have access under the current token to perform
					//the particular request
					grantedAccess = !!_.filter(token.scope, function(scope) {

						return !!requiredPermissions[scope.toLowerCase()];

					}).length;

					//IF the token is given access, then items do NOT matter
					if(grantedAccess) {


						//used for mongod when we're quering $in
						granters.push(token.granter);
						grantedTokens.push(token);

						//skip items since we're given global access to do whaterver
						//to this route
						continue;
					}

					//COLLECTION ACCESS PART

					//IF global access is not permitted to the given route, add the
					//items the user has access to. This is useful for gathering *all* items
					//the user might have access to - see groups. The items are used for $in
					for(var j = scope.length; j--;) {
						

						var scopeParts = scope[j].toLowerCase().split(':'),
						action     = scopeParts.shift(),
						collection = scopeParts.shift(),
						item       = scopeParts.shift() || '*';

						//make sure the item is used by this route, and there IS a specific
						//item
						if(!collections[collection] || item == '*') continue;

						//push the specific id
						collections[collection].push(ObjectId.fromString(item));
					}

				}


				console.log(tokens)
				if(!grantedTokens.length) return vine.error(new Error('not authorized')).end(res);


				//attach the tokens to the request so other middleware can access it
				req.sanitized.tokens = grantedTokens;

				granters.query    = { $in: granters };


				req.access = req.sanitized.access = {

					//used for specific routes owned by the granter
					owners: granters,

					//USED FOR COLLECTIONS
					collections: collections
				};



				if(!mw.next()) {
					vine.result(grantedTokens).end(res);	
				}

			}));
		}
	})
}