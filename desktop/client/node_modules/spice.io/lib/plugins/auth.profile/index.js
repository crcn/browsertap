var crypto = require('crypto'),
vine = require('vine'),
models = require('./model'),
_ = require('underscore'),
cashew = require('cashew'),
logger = require('winston').loggers.get('auth.profile'),
outcome = require('outcome'),
async = require('asyncjs');




exports.require = 'auth.session';

/*

Okay, so there's some distinction to be made. PROFILES are objects registered specific to the application, whereas ACCOUNTS are objects
which may be attached to any PROFILE. This could be a twitter/facebook/linkedin account. Profiles are simple, and contain basic information about a given user. 


*/

exports.plugin = function(router, params) {
   
	if(!params.fields) {

		params.fields = {
		 	'username': { 
			 	required: true, 
			 	type: 'String', 
			 	index: { 
				 	unique: true 
				 }
			}
		};
		
		params.usernameField = 'username';       
	}                                                                 
	                 
	params.fields.password = { 
		required: true, 
		type: 'String'
	};
	     
	params.fields.name = { 
		required: false, 
		type: 'String' 
	};                                    
	                                          
	var Profile;
                                            
	function _pass(str) {

		return crypto.createHash('sha1').update(str || '').digest('hex');
	
	}       
	

	function clone(obj) {
	 
		return JSON.parse(JSON.stringify(obj));
	
	}

	function cleanProfile(profile) {
		var prof = clone(profile);

		delete prof.password; delete prof.confirmPassword;
		return prof;
	}
	
	function getToken(ops, req, res) {


		if(!ops.granter) ops.granter = ops.profile._id;
		if(!ops.grantee) ops.grantee = ops.profile._id || ops.granter;

		//create a new token
		router.request('token').query({ granter: ops.granter, grantee: ops.grantee, scope: ops.scope }).success(function(response) {                   
			

			var token = response.result;

			var prof = _.extend({
				//deprecated            
				key         : token.key,
				ttl         : token.ttl,
				profile     : ops.grantee,
				accessToken : token.key,
				expiresAt   : token.expiresAt,
				scope       : token.scope,
				tokenId 	: token._id
			}, cleanProfile(ops.profile));


			if(req) req.token = token;

			vine.result(prof).message('Success!').end(res);
		}).pull();
	}      


	function getProfile(value, on) {

		if(typeof value == 'object') {

			on(null, value);

		} else {

			var search = [{username:value}];
			
			if(value.length == 24) {
				search.unshift({_id:value});
			}

			Profile.findOne({$or: search }, on.success(function(result) {

				if(!result) return on(new Error('Profile does not exist'));

				on(null, result);
			}));
		}
	}

	function filterOwnedScopes(owner, scope, callback) {

		async.list(scope).
		filter(function(item, next) {

			var itemParts = item.split(':'),
			level         = itemParts[0],
			collection    = itemParts[1],
			item          = itemParts[3];

			if(!item) return next(false, true);


			router.request('owns/' + collection + '/' + item, { owner: owner }).response(next).end();

		}).
		toArray(callback);
	}



	function grantAccess(ops, callback) {

		logger.verbose('granting access to user account');

		if(!callback) callback = function(){};


		var from = ops.from,
		to       = ops.to,
		scope    = ops.scope,
		on       = outcome.error(callback),
		self     = {};

		if(from) {
			
			getFrom(from);

		} else {
			
			var profile = new Profile();

			profile.save(on.success(getFrom));

		}


		function getFrom(from) {

			getProfile(from, on.success(function(newFrom) {
					
				getTo(newFrom);
				
			}));

		}

		function getTo(from) {

			getProfile(to, on.success(function(newTo) {
					
				grant(from, newTo, scope);

			}));

		}

		function grant(from, to, scope) {

			logger.verbose('granting access to account');

			filterOwnedScopes(to._id.toString(), scope, on.success(function(scope) {	

				logger.verbose(sprintf('scopes given to account: %s' , scope.join(', ')));
				
				if(!scope) return on(new Error("no scope provided"));			

				getToken({ 

					//link the token back to the original user
					granter: to._id, 


					profile: from, 

					//the profile we're LINKING to - the one with access to *THIS* account
					grantee: from._id,

					//the scope permissions
					scope: scope,
				}, null, function(response) {
					
					if(response.errors) return on(response.errors);


					return callback(null, response)
				});

			}));

		}
	}

	var tokenSecretGen = cashew.register('token');



	//fucking yuck.
	for(var field in params.fields) {

		if(field == 'password') continue;
		
		var route = {}, ops = params.fields[field];


		router.on('validate '+ (!ops.required ? '-optional ' : '') + '-key=' + field + ' auth' + field, function(req, next) {
			console.log('validate auth ' + req.property)
			return req.value;
		});
	}
 

	router.on({

		/**
		 */

		'validate -passive -key=token|accessToken|username -assign=profile credentials': function(req, next) {
			
			var search = {}, 
			self = {},
			on = outcome.error(next),
			tokenString = req.query.accessToken || req.query.token;

			if(tokenString) {
				
				logger.verbose('accessToken provided - checking if it exists...')

				findToken(tokenString);

			} else {

				if(req.sanitized.token) {
					logger.verbose('validating credits with token');
					search._id = req.sanitized.token.granter;
				} else {
					logger.verbose('validating credits with u/p');
					search.username = req.query.username;
					search.password = _pass(req.query.password);
				}

				findProfile(search);
			}
			

			
			function findToken(value) {
				
				router.request('token/' + value).error(next).success(onToken).pull();

			}		

			function onToken(response) {
				
				//pfffft >.>
				if(response.errors) return next(new Error('token does not exist'));


				findProfile({ _id: response.result.granter });
			}


			function findProfile(search) {

				Profile.findOne(search, on.success(onProfile));

			}


			function onProfile(profile) {

				//error? just pass to on profile - it sends the error anyways
				if(!profile) return next(new Error('profile does not exist'));

				req.sanitized.tokenGranter = profile._id;
				self.profile = profile;

				//register the token
				getToken({ profile: profile }, null, onNewToken);  
			}

			function onNewToken(response) {
					
				if(response.errors) return next(new Error('unable to validate'));

				next(null, self.profile);
			}
			
		},

		/**
		 */

		'validate -key=password authpassword': function(req, next) {
			return _pass(req.value);
		},

		/**
		 */

		'pull \
		-perm \
		tokens -> \
			validate/credentials -> \
			/**': function(req, res, mw) {


			logger.verbose('validated credentials, onto the private routes');

			mw.next();
		},

		/**
		 */

		'push \
		mongodb': function(db) {
			Profile = models(db, params).Profile;
 
		},

		/**
		 */
		
		'pull \
		-hook -method=GET \
		validate/credentials -> \
		validate/token -> \
			profile': function(req, res, mw) {
			
			req.profile = req.sanitized.profile;
			req.token   = req.sanitized.token;

			if(!mw.next()) {
				
				vine.result(_.extend({
					accessToken: req.token.key
				}, cleanProfile(req.profile))).end(res);
			}
					
		},      
               

        /**
         */

        'pull -method=GET -perm=USER -permItem=test validateTest/:test': function() {
        	
        },
		
		/**
		 * authorize another user particular actions against this account
		 */

		'pull \
		-hook -perm -method=GET \
			profile/authorize OR \
			profile/authorize/:scope OR \
			profile/authorize/:scope/:grantee': function(req, res) {

			var scopes = this.data('scope').toLowerCase().split(','),
			profile = req.profile;


			if(scopes.indexOf('super') > -1 || scopes.indexOf('user') > -1) return vine.error('Cannot grant SUPER or USER').end(res);


			//TODO: check token permissions and remove any permissions that aren't granted for given user - this is a security issue

			console.log('Granting user access to profile with scope: %s', scopes.join(' '));


			grantAccess({ from: this.data('grantee'), to: req.sanitized.profile, scope: scopes }, res.success(function(response) {
				res.end(response);
			}));
		},

		/**
		 * where the authentication layer begins
		 */
		
		'pull -perm=USER \
			my/**': function(req, res, mw) {       
		   
			mw.next();

		},

		
		/**
		 * returns a profile without authorization. This is for internal use.
		 */
		
		'pull \
		-private \
		profile/internal': function(req, res, mw) {

			Profile.findOne({ _id: req.profileId || req.query._id || req.query.profileId }, function(err, profile) {

				if(!profile) return vine.error('Profile does not exist').end(es);

				req.profile = profile;

				if(!mw.next()) return vine.result(profile).end(res);

			});

		},       
		

		/**!              
		 * Creates a new profile. This is a useful method for connecting an existing account, with one stored in spice.io.
		 * @example /profile/register?username={usernameStoredOnYourServer}&password={secretKey}
		 * @collection profile        
		 * @displayName createProfile
		 */

		'pull \
		validate/signup': function(req, res, mw) {
			
			var d = req.query;

			router.request('validate/auth' + Object.keys(params.fields).join('+auth')).query(d).success(function(response) {

				if((params.validateProfileCreation == undefined || params.validateProfileCreation == true) && (d.validate == undefined || d.validate == true) && response.errors) return vine.error(response.errors).end(res);

				req.sanitized = _.extend(response.result, req.sanitized);

				mw.next();
			}).pull();
		},

		'pull \
		-hook -method=POST \
		validate/signup -> \
			profile OR \
			profile/register': function(req, res) {
				
			var d = req.query,
			grant = req.sanitized.grant;

			
			var profile = new Profile(req.sanitized); 



			profile.save(function(err) {

				if(err) {

					logger.warn(err);
					return vine.error('that username already exists').end(res);  
					    
				}

				getToken({ profile: profile }, req, res);  

				if(grant) {

					grantAccess({ from: profile, to: grant.to, scope: grant.scope });	

				}
				
			});

		}
	});


}