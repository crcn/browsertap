var Structr = require('structr'),
MemCacher = require('sk/core/smart').smart.Cacher;


var CacheReader = Structr({
	
	/**
	 */

	'__construct': function(cache)
	{
		this._cache = cache;
	},

	/**
	 */

	'pipe': function(request)
	{
		request.respond(this._cache.response);

		for(var i = 0, n = this._cache.buffer.length; i < n; i++)
		{
			request.write(this._cache.buffer[i]);
		}

		request.end();
	}
});

var CacheWriter = Structr({

	/**
	 */

	'__construct': function(delegate)
	{
		this._delegate = delegate;
	},
	
	/**
	 */

	'pipe': function(request)
	{
		
	}
});

var CacheDelegate = function(db)
{
	var c_cache = db.collection('cache.data'),
	c_keys = db.collection('cache.keys'),
	self = this,
	cachedKeys = new MemCacher(1000000);

	// c_cache.ensureIndex({ query: 1 }, function(){});


	function _query(request, keys)
	{
		var query = [];

		if(keys)
		for(var i = keys.length; i--;)
		{
			var key = keys[i];
			query.push(key + '=' + escape(request.data[key]));
		}

		return query.join('&');
	}


	function _path(request)
	{
		var meta = [];

		for(var param in request.last.meta)
		{
			meta.push('-' + param + '=' + request.last.meta[param]);
		}
	
		meta.push(request.path);
		
		return meta.join(' '); 
	}


	this.get = function(request, callback)
	{
		var path = _path(request);

		self.getKey(path, function(keys)
		{
			// console.log(request.last);
			c_cache.findOne({ path: path, query: _query(request, keys) }, function(err, item)
			{
				if(item)
				{
					if(item.deleteAt.getTime() < new Date().getTime())
					{
						c_cache.remove({ _id: item._id }, function(){});
						callback(null);
					}
					else
					{
						callback(new CacheReader(item.value));
					}

					return;
				}

				callback(null);

			})	
		})
		
	}

	this.getKey = function(path, callback)
	{
		var keys = cachedKeys.get(path);

		if(keys) return callback(keys);

		c_keys.findOne({ _id: path }, function(err, item)
		{
			cachedKeys.set(item ? item.keys : null);

			callback(item ? item.keys : null);
		})
	}

	this.cache = function(request, ttl)
	{
		var response = {},
		buffer = [],
		path = _path(request),
		keys = request.data.keys ? request.data.keys.split('+') : [],
		group = request.data.group || new Date().getTime() + '.' + Math.round(Math.random() * 9999999);


		//otherwise, pipe the response
		request.pipe({
			respond: function(resp)
			{
				response = resp;

				if(resp.cache)
				{
					ttl  = resp.cache.ttl  || ttl;
					keys = resp.cache.keys || [];
				}

			},
			write: function(value)
			{
				//need to serialize / deserialize the object. might have toJSON, which isn't called when sent to the DB. 
				if(value instanceof Object) value = JSON.parse(JSON.stringify(value));

				buffer.push(value);
			},
			end: function()
			{
				self.setKey(path, keys);
				self.set({ path: path, query: _query(request, keys), group: group }, { response: response, buffer: buffer }, Number(ttl) * 1000);
			}
		});
	}


	this.setKey = function(path, keys)
	{
		cachedKeys.set(path, keys);

		c_keys.update({ _id: path }, { _id: path, keys: keys }, { upsert: 1 }, function(){});
	}

	this.remove = function(request, callback)
	{
		var group = request.data.group,
		keys = request.data.keys ? request.data.keys.split('+') : null;


		var query = {};

		if(group) query.group = group;
		if(keys) query.query = new RegExp(_query(request, keys));


		c_cache.remove(query, callback);
	}

	this.set = function(key, value, ttl)
	{
		var now = new Date();
		

		c_cache.update(key, { $set: { value: value, ttl: ttl, createdAt: now, deleteAt: new Date(now.getTime() + Number(ttl)) }}, { upsert: true }, function()
		{
		})
	}
}


module.exports = CacheDelegate;