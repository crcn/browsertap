var Url = require('url'),
nectar = require('./nectar'),   
Router = nectar.Router,  
shortUrls = nectar.shortUrls, 
Url    = require('url'),
http = require('http'),
MediaDelegate = require('./dbDelegate').MediaDelegate,
vine = require('vine');


exports.plugin = function(mediator) {


	var mdg = new MediaDelegate(),
		router = new Router(mediator);

	function init() {

		mediator.request('nectar').
		success(function(nectars) {

			router.addNectars([nectars]);
		}).
		collect();
	}
	
	function getAugmentor(req, res) {


		res.end(router.readability);

	}
	
	function getNectarizer(req, res) {


		res.end(router);

	}
	
	function augmentData(shortUrl, url) {


		var media = router.getAugmentedData(url);
		media.key = shortUrl;   
		return media;

	}
	
	//we do NOT want find all redirects if the host is not provided
	//in the list of urls to expand. This will create a bottleneck. 
	function findEndRedirect(parts,url,callback) {

	                          
		if(shortUrls.indexOf(parts.host) == -1)
			return callback(url);

		//NOTE: User-Agent sets up gzip...
	   	var headers = {
host:parts.hostname,'Accept-Encoding':'gzip, deflate','Accept':'*/*','Accept-Language':'en-us','User-Agent':'Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_5; en-us) AppleWebKit/533.19.4 (KHTML, like Gecko) Version/5.0.3 Safari/533.19.4','Connection':'keep-alive'}
		var client  = http.createClient(80,parts.hostname,false);   
		var data    =  parts.search || '';
		var req     = client.request('GET',(parts.pathname || '/') + data,headers)  

	    console.log(String('expanding: '+url).blue);  

		req.end();    
		req.socket.on('error',function(exec) {


			if(exec.stack)
			console.error(exec.stack.toString());
		})

		req.on('response',function(response) {
    
		                             
			longUrl = response.headers.location;   
			if(!longUrl) 
				return callback(url);   

			if(longUrl.indexOf('://') == -1) {
    
			                     
				longUrl = parts.protocol+'//'+parts.host+'/'+longUrl;
			}                      

			findEndRedirect(Url.parse(longUrl),longUrl,callback);

			response.pause();
			response.destroy(); 
		});
	}

	function expandUrl(url,callback) {
  
	                                   

		var parts = Url.parse(url);

		if(shortUrls.indexOf(parts.host) == -1)
			return callback(augmentData(url,url));

		mdg.getMedia(url,function(media) {
  
		                                    
			if(media) return callback(media);

			findEndRedirect(parts,url,function(longUrl) {


				mdg.setMedia(augmentData(url,longUrl),function(data) {


					callback(data);
				});
			});
		});
	}
	
	
	function getContentStandardizer(req, res) {
   	
	                
		var linkStd = {
    

			standardize: function(item) {
          
				if(!item.text) return;

				// var urls = text.match(/(((ht|f)tp(s?):\/\/)?(\w+:\w+@)?(([-\w]+)\.)+(com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum|travel|[a-z]{2})(:\d+)?.*?(?=[,:!?.]*(\s|$)))/g);

				//this matches http://google.com, when we don't want the comma...
			 	// var urls = text.match(/(((ht|f)tp(s?):\/\/)?(\w+:\w+@)?(([-\w]+)\.)+(com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum|travel|[a-z]{2})(:\d+)?[^()'"\s]*)/g);
		        var urls = item.text.match(/(((ht|f)tp(s?):\/\/)?(\w+:\w+@)?(([-\w]+)\.)+(be|co|com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|museum|travel|[a-z]{2})(:\d+)?.*?(?=[,:!?.'"\(\)]*(\s|$)))/g);

				for(var i in urls) {
      
				             
					var url = urls[i];

					//fuck it. this regex is obnoxious. doesn't strip out html >.> 
					router.addMedia(item.media,url.replace(/<.*/g,''));  
				}

				if(!item.link && url) item.link = url;            
			}
		};       
		
		var mdStd = {

			standardize: function(item) {

				//figure out the link type
				if(item.link) router.addMedia(item.media, item.link)
			}
		}
		
		//augments links
		res.write(linkStd);  
		res.end(mdStd);
	}
	
	function nectarizeItem(req, res) {

		res.end(router.getAugmentedData(pull.data));
	}

	function initMaster() {

		//http routes
		mediator.on({

			/**!
			 * Augments the target url(s). 
			 * @param urls JSON array of urls
			 * @collection augment   
			 * @displayName augmentUrls
			 */

			'pull -method=GET -http nectars/augment': function(req, res) {


				try {
    
					var urls = JSON.parse(this.data.urls);  

					var q = new Queue(true);   
					var expanded = [];

					urls.forEach(function(url) {
                          
						q.add(function() {

							expandUrl(url,function(url) {
                         
								if(url) expanded.push(url);
								q.next();
							}) 
						});
					}); 

					q.add(function() {
   
						vine.api().result(expanded).send(res);
						q.next();
					});

				} catch(e) {
                 
					console.error(e.stack.toString())
					vine.api().error("invalid format. Please send the urls in a JSON format.").end(res);
				}  
			}


		})
	}
	
	mediator.on({
		'pull -hook nectarize': nectarizeItem,
		'push init': init,
		'push init/master': initMaster,
		'pull augmentor': getAugmentor,
		'pull nectarizer': getNectarizer,
		'collect content/standardizer': getContentStandardizer
	})
}
