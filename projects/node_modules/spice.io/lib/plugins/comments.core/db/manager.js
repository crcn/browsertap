var models = require('./models');

exports.delegates = function(db)
{
	
	var m = models(db);
	
	return {
		commentsDelegate: new CommentsDelegate(m.CommentsModel, m.CommentVotesModel)
	}
}

var CommentsDelegate = function(CommentsModel, CommentVotesModel)
{
	// this.get
	
	var commentHandlers = {};

	this.getComments = function(targetId, type, sortBy, callback)
	{
		CommentsModel.find({ target: targetId, type: type }, function(err, items)
		{
			callback(items);
		});
	}
	
	
	//handles removal, and addition of comments
	this.registerCommentsHandler = function(handler)
	{
		commentHandlers[handler.type] = handler;
	}
	
	function incDecNumComments(target, type, incDec)
	{
		
		var handler = commentHandlers[type];
		
		if(handler)
		{
			handler.incrementComments(target, incDec);
		}
	}

	this.addComment = function(profile, targetId, type, text, callback)
	{
		incDecNumComments(targetId, type, 1);

		var comment = new CommentsModel({ user: profile._id, userInfo: { displayName: profile.displayName, type: profile.type }, target: targetId, type: type, text: text, createdAt: new Date() });
		comment.save(function()
		{
			callback(comment)
		});

	}

	this.removeComment = function(profile, commentId, callback)
	{
		CommentsModel.findOne({ _id: commentId, user: profile }, function(user, comment)
		{
			if(comment)
			{	
				incDecNumComments(comment.target, comment.type, -1);
				comment.remove(callback);
			}
		});
	}

	function upvoteDownvoteItem(userId, commentId, upvote, callback)
	{
		CommentsModel.findOne({ _id: commentId }, function(err, comment)
		{
			if(!comment)
			{
				return;
			}

			CommentVotesModel.findOne({ user: userId, comment: commentId }, function(err, item)
			{
				var likes = 0,
				dislikes = 0;

				if(item)
				{
					if(item.upvote == upvote)
					{
						return;//no change
					}
					else

					//or, if the item is an upvote, the user has changed their mind to a downvote
					if(item.upvote)
					{
						likes--;
					}

					//otherwise the user has changed their mind to an upvote
					else
					{
						dislikes--;
					}

					CommentVotesModel.collection.update({ _id: item._id }, {$set: {upvote: upvote }}, function(){})
				}
				else
				{
					var vote = new CommentVotesModel({ user: userId, comment: commentId, upvote: upvote });
					vote.save();
				}


				if(upvote)
				{
					likes++;
				}
				else
				{
					dislikes++;
				}

				var totalLikes = (comment.likes || 0) + likes,
				totalDislikes = (comment.dislikes || 0) + dislikes;

				score = totalLikes - totalDislikes;

				// console.log(score+" "+totalLikes + " "+ totalDislikes+" "+likes+" "+dislikes)


				comment.likes = totalLikes;
				comment.dislikes = totalDislikes;
				comment.score = score;

				CommentsModel.collection.update({ _id: comment._id }, {$set:{ likes: totalLikes, dislikes: totalDislikes, score: score}}, function()
				{

				})
				comment.save();


			});
		});


		callback();
	}

	this.upvoteComment = function(userId, commentId, callback)
	{
		upvoteDownvoteItem(userId, commentId, true, callback);
	}

	this.downvoteComment = function(userId, commentId, callback)
	{
		upvoteDownvoteItem(userId, commentId, false, callback);
	}
	
	
	this.registerCommentsHandler({
		type: 'reply',
		incrementComments: function(target, n)
		{
			CommentsModel.collection.update({ _id: objectId(target) }, {$inc : { numComments: n } }, function(){});
		}
	});
}