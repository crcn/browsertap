var GoogleAuthHandler = require('./auth').GoogleAuthHandler,
	net = require('psk/node/io/net'),
	URLRequest = net.Request,
	loadRequest = net.loadRequest,
	findFeed = require('psk/node/xml/findFeed').load;

exports.plugin = function(router, params)
{       

	var auth = new GoogleAuthHandler(params);
	     

	var getAuthHandler = function()
	{
		return auth;
	}
	
	var service =  new (function()
	{				
		this.auth = auth;
		var self = this;
		
		this.getAccountFeeds = function(account, callback)
		{
			auth.get('http://www.google.com/reader/api/0/subscription/list?output=json',account,null,function(err,result)
			{
				var data = JSON.parse(result),
				feeds = [];

				for(var i = data.subscriptions.length; i--;)
				{
					var sub = data.subscriptions[i];

					var name = sub.categories.length ? sub.categories[0].label : 'google reader',
					feed = sub.id.replace('feed/','').replace('https','feed').replace('http','feed');

					feeds.push({ group: name, feed: feed });
				}


				callback(feeds)
			});
		}    
		
		function getToken(account, callback)
		{
			auth.get('http://www.google.com/reader/api/0/token', account, null, callback);
		}   
		
		this.subscribed = function(account, feed, callback)
		{                                                                                      
			findFeed(feed, function(err, urls)
			{                                    
				if(urls) feed = urls[0].url;
				
				feed = feed.replace('http','feed');
				
				self.getAccountFeeds(account, function(groups)
				{                                       
					for(var i = groups.length; i--;)
					{                                   
						// console.log(groups[i].feeds); 
						// console.log(feed)
						if(groups[i].feeds.indexOf(feed)+1) return callback(false, true);
					}    
					
					return callback(false, false);
				});  
		    });
		}
		
		                                     
		this.subscribe = function(account, feed, callback)
		{                                
			getToken(account, function(err, token)
			{                                        
				auth.post('http://www.google.com/reader/api/0/subscription/quickadd?client=scroll', account, { quickadd: feed, T: token }, function(err, result)
				{                         
					try
					{                  
						var result = JSON.parse(result);
						callback(false,result)
						
					}catch(e)
					{
						callback(true);
					}
				})

			});
		}
		
		this.unsubscribe = function(account, feed, callback)
		{

			getToken(account, function(err, token)
			{                                                 
				//google doesn't support unsubscribing based on url, so we need to find the original feed
				findFeed(feed, function(err, urls)
				{                                      
					if(urls) feed = urls[0].url;
                                            
					auth.post('http://www.google.com/reader/api/0/subscription/edit?client=scroll', account, { ac: 'unsubscribe', s: 'feed/'+feed, T:token }, function(err, result)
					{                           
						callback(err, result)
					})    
				})
			});
		}
	}
	)()
	
	function getSocialService(req, res)
	{

		var info = 
		{
			type:'graph'
			,name:'Google'
			,service: service,
			loaders:
			{
				default:
				{
					reader:
					{
						name:'Reader' 
						,load:function(data,callback)
						{
							// this.service.loadData({screen_name:data.q},'getUserTimeline',callback);
						}  
					}
				},
				feeds: 
				{
					pull: 
					{
						name:'Feed Synchronizer',
						params: { account: 1 },
						load: function(ops, callback)
						{
							service.getAccountFeeds(ops.account, function(scenes)
							{
								callback(scenes);
							})
						}
					}
				}
			}
		}


		res.end(info);
	}
	
	
	function getSuggestionHandler(req, res)
	{
		var handler = {
			name: 'google',
			findSuggestions: function(q, callback)
			{
				var req = new URLRequest('http://www.google.com/uds/GfindFeeds');
				req.data = { q: q, v: '1.0' };

				loadRequest(req, function(result)
				{
					try
					{
						result = JSON.parse(result);

						var entries = [];

						result.responseData.entries.forEach(function(entry)
						{
							entries.push({
								label: entry.title,
								type: 'rss',
								url: entry.url,
								text: entry.contentSnippet
							})
						});
					}
					catch(e)
					{
						return callback([]);
					}

					callback(entries);
				});
			}
		};
		
		res.end(handler);
	}   


	function getFeedPuller()
	{
		return {
			type: 'reader',
			service: 'google',
			load: function(account, delegate)
			{
				service.getAccountFeeds(account, function(feeds)
				{
					delegate.finish(feeds);
				});
			},
			unsubscribe: function(account, feed, callback)
			{
				service.unsubscribe(account, feed.feed, callback);
			},
			subscribe: function(account, feed, callback)
			{
				service.subscribe(account, feed.feed, callback);
			}
		}
	}
	
	router.on({   
		'collect feed/puller': getFeedPuller,
		'collect connect/auth': getAuthHandler,
		'pull connect/auth/google': getAuthHandler,
		// 'collect subscribable':  getSubscribable,
		'collect social/service': getSocialService,
		'collect suggestion/handler': getSuggestionHandler
	})
};
