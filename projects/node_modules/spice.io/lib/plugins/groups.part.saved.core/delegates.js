var EventEmitter = require('sk/core/events').EventEmitter,
	utils = require('sk/node/utils'),
	vine = require('vine'),
	cashew = require('cashew'),
	outcome = require('outcome');

// console.log(require('mongodb').BSONNative)

exports.SavedArticlesDelegate = function(router, params, db, c_savedArticles)
{
	// var savedCacher = new SavedFeedsCacher('savedFeed',db),
	var self = this,
		searchClient,
		idgen = cashew.register('saved.articles');
		
		
	new EventEmitter().copyTo(this);


	router.on({
		'collect search/client': function(req, res)
		{
			res.end({
				name: params.ftsIndex || 'saved',
				init: function(callbacks)
				{
					self.addListener('newSaved', function(data)
					{
						callbacks.addSearchable(data);
					});
				}
			});
		}
	});

	this.getArticle = function(groupId, articleId, callback)
	{
		c_savedArticles.findOne({ group: groupId.toString(), _id: articleId }, function(err, item)
		{
			callback(vine.result(item));
		})
	}
	
	


	this.updateArticle = function(groupId, articleId, data, callback)
	{
		var toUse = ['link','label','text','media'],
		toUpdate = {};

		for(var i = toUse.length; i--;)
		{
			var prop = toUse[i];

			if(data[prop]) toUpdate[prop] = data[prop];
		}

		c_savedArticles.update({ group: groupId.toString(), _id: articleId }, { $set: toUpdate }, function(err, items)
		{
			callback(vine.update(toUpdate));	
		});
	}
	
	this.getSavedArticles = function(groupId, data, callback)
	{
		var search = {group:groupId.toString()},
			ops = {};
		
		if(!data.count) data.count = 30;
		if(!data.page) data.page = 0;
		if(data.afterDate) search.createdAt = { $gt: new Date(data.afterDate) };
		                      
		data.count = Math.min(Number(data.count), 50);
		
		ops.skip = Number(data.page) * Number(data.count);
		ops.limit = data.count;
		ops.sort = [['createdAt',-1]];
		
		var searchCached = { groupId: groupId, skip: ops.skip, count: ops.count };
			
		function onSavedItems (items)
		{
			callback(typeof items == 'string' ? items : vine.result(items));
		}                 
		
		
		c_savedArticles.find(search, ops, function(err, cursor)
		{
			cursor.toArray(function(err, items)
			{
				// if(cache && items.length) savedCacher.store(searchCached, items);
				
				onSavedItems(items)
			});
		});
	}
	
	//there is a delay between when the user can see any new favorites, because the backend doesn't promote items immediately.
	this.saveArticle = function(groupId, item, callback)
	{                  
		if(item.doc) item = item.doc;
		
		     
		c_savedArticles.findOne({ link: item.link, group: groupId.toString() }, outcome.success(function (existing)
		{                              
			if(existing) return callback(vine.error("You've already saved this item."));
                                            
			item.group = groupId.toString();                       
			if(item.createdAt) item.publishedAt = item.createdAt;
            item.createdAt = new Date();                   
			

			//useless shit in saved items
			utils.deleteKeys(['likes',
			'dislikes', 
			'heat', 
			'score', 
			'promoDetails',
			 'tries', 
			'lockCount',
			'icon',
			'_id',
			'augmented',
			'feeds',
			'nextUpdate'],item);
			

			item._id = idgen.uid();
			

			//remove the cached items for the given 
			c_savedArticles.insert(item, outcome.success(function (item)
			{
				router.push('notify/subscribers', { group: groupId.toString(), type: 'saved' });
				self.emit('newSaved', item);
				
				callback(vine.add(item))
			}));
		}));  
	}
	
	this.unsaveArticle = function(groupId, articleId, callback)
	{
		var search = { group: groupId.toString(), _id: articleId };  
		
		
			
		c_savedArticles.remove(search, function (err, item)
		{
			callback(vine.result(true));
		})
	}
	                                    
}       
