var Structr = require('structr'),
ConcreteModel = require('malt').models.Model,
Instructor = require('../instructor'),
logger = require('mesh-winston').loggers.get('fig'),
renderView = require('../renderView');



var View = module.exports = ConcreteModel.extend({

	/**
	 */

	'_binders': {


		/**
		 * binds events to the view
		 */


		'default': function(action, target, method)
		{
			var self = this;


			target.bind(action, function(event)
			{
				//otherwise, prevent the user from redirecting, and handle the request in-app
				event.preventDefault();

				self[method].call(self, event);
			})
		},

		/**
		 * binds enter on the keyboard for the view
		 */

		'enter': function(action, target, method)
		{
			var self = this;

			target.bind('keydown', function(event)
			{
				if(event.keyCode == 13)
				{
					self[method].call(self, event);
				}
			})
		}	
	},


	/**
	 */

	'override __construct': function(ops)
	{
		this._super();
		this._children = [];
		this._childrenByName = {};


		this.setup(ops);

		this._instructor = new Instructor(this);
	},

	/** 
	 * configures the view
	 */

	'setup': function(ops)
	{
		if(!ops) ops = {};
		if(!this.ops) this.ops = {};
		if(ops.el) this.el = ops.el; 



		Structr.copy(ops, this.ops, true);
		
		this.body = ops.body;
		if(ops.template) this.template = ops.template;  
		

		//web, or node
		this.$$ = typeof $ != 'undefined' ? $ : ops.$;
		this.document = typeof document != 'undefined' ? document : ops.document;

		return this;
	},


	/**
	 * updates the view if anything changes. This usually occurs if say... data changes at it impacts
	 * a template view, OR the parent changes, and the children need to change as well
	 */

	'update': function(force)
	{
		//reset the element. What if the parent innerHTML has changed? 
		if(!force && !this._setElement()) return; 		


		//now, set the view
		this.render();

		//listen to the element
		this.listen();

		//need to update all the children now. TODO: check if the element *really* changed / was replaced
		this.updateChildren();
	},

	/**
	 */

	/**
	 * initialize
	 */

	'abstract ready': function() { 
	},

	/**
	 */

	'abstract render': function() { },

	/**
	 * updates the children
	 */

	'updateChildren': function()
	{
		this.eachChild(function(child)
		{
			child.update();
			child.updateChildren();
		})
	},
  
	/**
	 */

	'eachChild': function(callback)
	{
		for(var i = this._children.length; i--;)
		{
			callback(this._children[i], i);
		}
	},

	/**
	 * adds a child to the view
	 */


	'addChild': function(view, name)
	{
		//this shouldn't happen, but just in case, we don't want to break
		//the app
		if(!view)
		{
			console.warn('Cannot add null child to ' + this.selector);
			return;
		}

		//allow the child to do shit to the parent
		view.parent = this;

		//name exists? set it
		if(name) view.name = name;

		//the view name might already exist, so af'dd it to the collection
		if(view.name) this._childrenByName[view.name] = view;

		//push the child to the children collection
		this._children.push(view);	


		//is this view *completely* done initializing? Yeah, then we need
		//to initialize the child
		if(this.initializedChildren) this._linkChild(view).init();

		return view;
	},

	/**
	 * removes the view from the parent
	 */

	'remove': function()
	{
		if(this.parent)
		{
			this.parent.removeChild(this);
		}	
	},

	/**
	 * removes a child from the view
	 */


	'removeChild': function(viewOrIndex)
	{
		var view, index, toi = typeof viewOrIndex;


		//is the value an number? it's an index
		if(toi == 'number')
		{
			view = this._children[viewOrIndex];
			index = viewOrIndex;

		}

		//or a string? it's the name of the child
		else
		if(toi == 'string')
		{
			view = this._childrenByName[viewOrIndex];
			index = this._children.indexOf(view);
		}

		//otherwise we're remoiving the ref
		else
		{
			index = this._children.indexOf(view);
			view = viewOrIndex;

		}

		//but the view might not exist, so return null to notify it doesn't...
		if(!view) return null;


		delete this._childrenByName[view.name];

		view.parent = null;

		//destroy the child
		view.dispose();
		view.el.innerHTML = '';

		//exists? remove
		if(index > -1) this._children.splice(index, 1);

		return view;
	},

	/**
	 * removes all the children of the view
	 */

	'removeAllChildren': function()
	{
		while(this._children.length) this.removeChild(0);
	},

	/**
	 * returns a child by its name. Important especially for caching routes
	 */

	'getChildByName': function(name)
	{
		return this._childrenByName[name];
	},

	/**
	 * used for a beanpole request. renders the view, and sends it to the requestor
	 */

	'send': function(res)
	{
		logger.debug('send view');

		renderView(this, res);

	},


	/**
	 * initializes the few. Used primarily for serviing static pages 
	 */

	'init': function(callbacks)
	{
		this.subscribe(callbacks);
		

		//initialize happens only *once*, and it's used to serve up static pages, so don't run through it again
		if(this.initialized) return;
		this.initialized = true;

		var self = this;

		this.subscribe('complete', function()
		{	
			self.ready();	
		});

		//build up the instructions to display the view. This is essential for serving static pages
		this._instructor.add(['_setElement'].concat(this.instructions()).concat(['_listen', '_initChildren']));

	},


	/**
	 * the instructions to build up the view for static pages
	 */
	
	'instructions': function()
	{
		return ['_render'];
	},


	/**
	 * completely disposes the view so it's unusable
	 */

	'override dispose': function()
	{
		this._super();

		//remove from the parent
		this.remove();

		//clean for any listeners
		this.clean();


		//finally, remove *all* children
		this.disposeChildren();
	},

	/**
	 * disposes *all* children. important because it also removes all bindings
	 */

	'disposeChildren': function()
	{
		this.eachChild(function(child)
		{
			//removing does the same as disposing.
			child.remove();
		})
	},


	/**
	 * cleans an element before re-rendering
	 */

	'clean': function()
	{
		this.unbind();
	},

	/**
	 * unbinds all events from the current element
	 */

	'unbind': function()
	{
		this.$('*').unbind();
	},

	/**
	 * listens to the current element for any changes. 
	 */

	'listen': function()
	{

		//element does not exist, of the window is undefiend? it's being rendered on the backend. We *don't* want to listen
		//to any elements on the backend
		if(!this.el || typeof window == 'undefined') return;

		var self = this;


		this.unbind();


		function listen(ev, method)
		{
			var parts = ev.split(' '),
			type = parts.shift();
			
			parts.forEach(function(el)
			{
				$(self.el).find(el).each(function()
				{
					var fn = (self._binders[type] || self._binders['default']);

					fn.call(self, type, $(this), method);
				});
			});
		}
		
		
		for(var ev in self.bindings)
		{
			listen(ev, self.bindings[ev]);
		}
	},

	/**
	 * localized selector. Not global
	 */

	'$': function(search)
	{	
		return typeof search == 'string' ? this.$$(this.el).find(search) : this.$$(search);
	},

	/**
	 * links the child to the parent so 
	 */

	'_linkChild': function(child)
	{

		//set the original jquery function
		child.$$ = this.$$;

		//set the document so we have something to write to
		child.document = this.document;


		return child;
	},


	/**
	 * sets the element controlled by this view. Can changes on each update.
	 */

	'_setElement': function(next)
	{
		var currentElement = this.el,
		newElement = this.el;


		
		if(typeof newElement == 'string' || this.selector)
		{
			if(!this.selector) this.selector = this.el;

			if(this.parent)
			{
				var el = this.el;
				newElement = this.$$(this.parent.el).find(this.selector);
			}
			else
			{
				newElement = this.$$(this.selector);
			}
		}
	
		// this.jqel = this.parent ? this.$$(this.parent.el).find(this.selector) : this.$$(this.selector);
		

		//don't wrap in jquery
		if(newElement.context)
		{
			var newElement = newElement[0];
		}
		

		//clean up the old element before setting the new one...
		if(newElement && currentElement != newElement)
		{
			if(currentElement) this.clean();
			this.el = newElement;
		}

		if(next) next();

		//tells if whether a new element was really set...
		return currentElement != newElement;
	},

	/**
	 */

	'_render': function(next)
	{
		this.render();
		next();
	},

	/**
	 * part of the initialization. this happens ONLY on the front end of things
	 */

	'_listen': function(next)
	{
		this.listen();
		next();
	},

	/**
	 * initializes the children for their first push
	 */

	'_initChildren': function(next)
	{ 
		if(this.initializedChildren) return;
		this.initializedChildren = true;

		var running = this._children.length;


		if(!running)
		{
			return next();
		}


		function nextChild()
		{
			if(!(--running)) next();
		}


		for(var i = running; i--;)
		{
			var child = this._linkChild(this._children[i]);

			if(child.complete)
			{
				nextChild();
				continue;
			}

			this._children[i].init({
				complete: nextChild
			});
		}
	}
});


