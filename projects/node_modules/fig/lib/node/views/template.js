var model = require('./model'),
View = require('./concrete'),
Parser = require('../template/parser'),
logger = require('mesh-winston').loggers.get('fig'),
sprintf = require('sprintf').sprintf;

var TemplateViewPartial = {
	
	/**
	 */

	'override setup': function(ops) {

		this._super(ops);

		this.tpl = this.ops.tpl || this.tpl;

		return this;

	},


	/**
	 * the data to use to fill in the template
	 */

	'templateData': function() {

		return { };

	},

	/**
	 * render the template
	 */


	'override render': function() {

		var self = this, _super = this._super;

		if(!this.templateSource) return;

		var scriptsRegexp = /<script.*?>[\w\W]*?<\/script>/g;

		var scripts = this.templateSource.match(scriptsRegexp) || [],
		placeHolder = '||||script||||';
		
		
		//we need to TEMPORARILY block out templates so they don't get parsed on load
		Parser.parse(this.templateType, this.templateSource.replace(scriptsRegexp, placeHolder), this.templateData(), function(content) {

			if(!content) content = self.templateSource;

			while(scripts.length) {

				content = content.replace(placeHolder, scripts.shift());

			}

			//server-side?
			if(typeof window == 'undefined') {

				self.el.innerHTML = String(content);

			} else {

				self.$$(self.el).html(String(content));

			}		

		});	

		_super.call(this);
	},

	/**
	 */

	'override instructions': function() {
		return ['_loadTemplate'].concat(this._super());
	},

	/**
	 * loads in a template, this should happen *once*
	 */

	'_loadTemplate': function(next) {

		logger.verbose(sprintf('loading template %s', this.tpl));

		if(this.el == this.document && typeof window != 'undefined') {
			logger.warn('Unable to load template because element is document');
			return next();
		}

		if(!this.tpl || this.loadedTemplate) {

			console.warn('Cannot load template');

			return next();

		}

		this.loadedTemplate = true;

		var self = this;

		function onTemplate(source, type) {

			logger.verbose('loaded template');

			self.templateSource = source;
			self.templateType = type;
			next();
			
		}

		if(this.tpl.substr(0, 1) == '#') {

			var el = this.document.getElementById(this.tpl.substr(1));

			//text/x-tmpl-
			if(el) {

				onTemplate(el.innerText || el.text || el.textContent, el.getAttribute('type').substr(12));

			} else {

				console.warn('Template %s does not exist', this.tpl);

			}
		} else {


			this.router.request('template').query({ name: this.tpl }).headers({ cache: true }).success(function(content) {

				onTemplate(content, self.tpl.split('.').pop());

			}).pull();

		}
	}
}


var ModelTemplatePartial = {
	

	/**
	 */

	'templateData': function() {

		return this.data ? this.data().doc : {};

	}
};

exports.Template           = View.extend(TemplateViewPartial);
exports.ItemTemplate       = model.Item.extend(TemplateViewPartial, ModelTemplatePartial);
exports.CollectionTemplate = model.Collection.extend(TemplateViewPartial, ModelTemplatePartial);