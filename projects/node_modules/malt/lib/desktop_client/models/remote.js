var AbstractModel = require('./abstract'),
logger = require('mesh-winston').loggers.get('malt'),
sprintf = require('sprintf').sprintf;


module.exports = AbstractModel.extend({
	

	/**
	 * syncs the model from the server
	 */

	'sync': function(listeners)
	{
		if(this.loaded)
		{
			if(listeners.loaded) listeners.loaded();

			return;	
		}

		this.subscribe(listeners);

		this.load();

		return this;
	},

	/**
	 */

	'unsync': function()
	{
		if(this._listener)
		{
			this._listener.dispose();
			this._listener = null;
		}	

		return this;
	},


	/**
	 */

	'load': function(method, data, callback)
	{
		if(typeof method == 'object')
		{
			callback = data;
			data = method;
			method = undefined;
		}

		if(typeof method == 'function')
		{
			callback = method;
			method = undefined;
			data = undefined;
		}

		if(!callback) callback = function(){}
              	       	

                                                 

		if(this._loading) {
			logger.warn(sprintf('Cannot load method "%s" because the model is still loading', this._path()));
			return;
		}

		this._loading = true;

		var self = this;
		
		var callSuccess = this._load(method, data, function(response)
		{
			self.loaded = true;

			self._onResponse(response);

			//really - only ONE error should be sent back at a time. Multiple errors
			//should be handled on the client-side of things. 
			if(response.errors) {
				callback(new Error(response.errors[0].message));
			} else {
				callback(null, response.result);
			}

			self._loading = false;
			self.change('loaded', self);
		});   
		
		if(!callSuccess && callback)
		{
			callback(new Error('route does not exist'));
		}
			
		return this;
	},

	/**
	 */

	'_load': function(method, data, callback)
	{ 
		return this._pull(method, data, callback);	
	},


	/**
	 */

	'toJSON': function()
	{
		return this.doc;
	},

	/**
	 */

	'_path': function()
	{
		return this.path;
	},

	/**
	 */

	'_onResponse': function(response)
	{
		//abstract
	},

	/**

	 */

	'_pull': function(method, data, onResponse)
	{
		if(typeof data == 'function')
		{
			onResponse = data;
			data = null;
		}         
		
		logger.debug(sprintf('Malt pull method=%s path=%s', method, this._path()));    
		 
		return this.router.
		request(this._path()).
		header('method', method || 'GET').
		error(function(err) {
			logger.error(err.stack);
		}).
		success(function() {
			if(onResponse) onResponse.apply(null, arguments);
		}).
		query(data).
		pull();               
	},


	/**
	 */

	'_initPush': function()
	{
		if(this._listener) return this;

                         

		this._listener = this.router.on(this._path(), { type: 'push', meta: { 'public': 1 } }, this.getMethod('_onResponse'));	
		return this;
	}

});



