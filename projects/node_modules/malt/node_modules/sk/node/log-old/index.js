require('colors');

var EventEmitter = require('events').EventEmitter,
	lazyCallback = require('../../core/lazy').lazy.callback,
	fs = require('fs'),
	Queue = require('../../core/queue').Queue,
	utils = require('../utils'),
	stringFormat = require('../../vendors/format').format,
	dateFormat = require('dateformat'),
	sys = require('util');



var _loggerPartial = function(target, emit, ops)
{
	
	target[ops.name] = function()
	{
		var msg = arguments[0];
		
		if(typeof msg == 'object')
		{
			msg = sys.inspect(msg, false, null);
		}
		else
		{
			arguments[0] = arguments[0]+'';

			try
			{
				msg = stringFormat.apply(null, arguments);
				//breaks sometimes
			}catch(e)
			{
				
			}
		}


		if(ops.color) msg = msg[ops.color];
		
		
		process.stdout.write(ops.controls.prefix + msg + '\n');
		
		emit(ops, msg);
	}
}

//newLogger = deprecated

exports.logger = exports.newLogger = function(ops)
{
	if(!ops) ops = {};
	
	var target = ops.target || {};
	
	if(target.controls)
	{
		return target.controls;
	}
	
	var logPath = ops.path,
	em = new EventEmitter(),
	logsToSave = {},
	loggers = {};

	var madeDir = false;
	var saveLogs = lazyCallback(function()
	{
		var logPath = controls.path;
		
		if(!logPath) return;

		var logs = logsToSave;
		logsToSave = {},
		q = new Queue(true);
		
		if(!madeDir) utils.mkdir_r(logPath);

		function writeLogs(fileName, stack)
		{
			var filePath = controls.path + '/' + fileName + '.log';
						
			q.add(function()
			{
				//build up the log stack
				for(var i = stack.length; i--;)
				{
					var log = stack[i];
					
					buffer = dateFormat(log.createdAt, 'ddd mmm d h:MM:ss TT Z') + ' - ' + log.ops.name.toUpperCase() + ': ' + log.message.replace(/\[\d+\w/g,'') + '\n' + buffer;
				}
				
				var ws = fs.createWriteStream(filePath, {'flags': 'a'});

				// use {'flags': 'a'} to append and {'flags': 'w'} to erase and write a new file
				ws.write(buffer, function()
				{
					q.next();
					ws.end();
				});
			});
		}

		for(var fileName in logs)
		{
			var stack = logs[fileName],
			buffer = '';

			writeLogs(fileName, stack);
		}

	}, 
	500);

	function emit(ops, message)
	{
		var log = { createdAt: new Date(), ops: ops, message: String(message) };
		
		em.emit('log', log);
		
		if(controls.path && ops.fileName)
		{
			if(!logsToSave[ops.fileName]) logsToSave[ops.fileName] = [];

			logsToSave[ops.fileName].push(log);

			saveLogs();
		}
	}

	var controls = {
		
		path: logPath,
		prefix: '',
		modify: function(name, enabled, color, fileName)
		{
			loggers[name] = { color: color, enabled: enabled, name: name, fileName: fileName == true ? name : fileName, controls: controls };
			
			if(enabled)
			{
				_loggerPartial(target, emit, loggers[name]);
			}
			else
			{
				target[name] = function(){};
			}
		},
		verbose: function()
		{
			// controls.enable('')
		},
		logPaths: function()
		{
			if(!controls.path) return [];
			
			var paths = [];
			
			for(var logType in loggers)
			{
				if(loggers[logType].enabled && loggers[logType].fileName) paths.push(controls.path + '/' + loggers[logType].fileName + '.log')
			}
			
			return paths;
		},
		enabled: function()
		{
			var stack = [];
			
			for(var logType in loggers)
			{
				if(loggers[logType].enabled) stack.push(logType)
			}
			
			return stack;
		},
		
		//deprecated
		logger: target,
		target: target
	};
	
	target.controls = controls;
	
	
	//deprecated
	controls.modify('message',true, null);
	controls.modify('verbose',false, 'blue');
	
	//deprecated
	controls.modify('notice', true,'grey', 'log');
	controls.modify('log', true,null, 'log');
	controls.modify('success',true, 'green', 'log');
	controls.modify('ok',true,'magenta','log');
	
	//deprecated
	controls.modify('fail',false,'red'); 
	controls.modify('warning',true,'yellow','log');
	controls.modify('warn',true,'yellow', 'log');
	controls.modify('error',true,'red', 'err');

	return controls;
}


if(!global.__setLogger)
{
	global.__setLogger = true;
	exports.logger({ target: console });
}
